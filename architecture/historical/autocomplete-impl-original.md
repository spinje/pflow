---
**⚠️ HISTORICAL DOCUMENT**

**Reason**: Describes autocomplete implementation for `=>` CLI composition syntax that was never implemented. pflow uses JSON workflow files for composition.

**For Current CLI**: See `architecture/reference/cli-reference.md` or run `pflow --help`

---

# Implementation Document: `pflow` CLI Autocomplete

> **Version**: v2.0
> **MVP Status**: ❌ Deferred to v2.0
> For complete MVP boundaries, see [MVP Implementation Guide](../features/mvp-implementation-guide.md)

## 1. Introduction

This document outlines the implementation details for the Command-Line Interface (CLI) Autocomplete feature for `pflow`. This feature enhances user experience by providing real-time suggestions for commands, node names, flags, and values directly within the user's shell environment. It aims to improve discoverability, reduce errors, and streamline the process of composing `pflow` flows.

The implementation leverages `pflow`'s existing Node Metadata and Unified Registry systems and integrates with common shell environments without requiring a REPL.

## 2. Core Mechanism: Shell Integration

The autocomplete functionality relies on a standard pattern of shell integration:

1. **Completion Script:** `pflow` provides a command to generate a shell-specific completion script (e.g., for Bash, Zsh, Fish).
2. **User Configuration:** The user sources this script in their shell's configuration file.
3. **Shell Callback:** When the user presses the `TAB` key while typing a `pflow` command, the shell executes a function defined in the completion script.
4. **`pflow` Invocation:** This shell function calls the `pflow` CLI with special arguments, passing the current command line content.
5. **Suggestion Generation:** `pflow` analyzes the input and returns a list of potential completions.
6. **Display:** The shell displays these suggestions to the user.

## 3. `pflow` CLI Extensions for Autocomplete

### 3.1 `pflow completion <shell_name>` Command

This new user-facing command will generate the necessary completion script for the specified shell.

* **Usage:** `pflow completion <bash|zsh|fish|powershell>`
* **Output:** Prints the completion script for the specified shell to standard output.
* **Example User Action (Bash):**

    ```bash
    pflow completion bash >> ~/.bash_completion # Or directly into .bashrc/.profile
    source ~/.bash_completion # Or re-login
    ```

### 3.2 Internal Completion Request Command

The generated shell scripts will call `pflow` using a dedicated internal interface to request completions.

* **Proposed Command:** `pflow --_pf-autocomplete-generate`
* **Arguments Passed by Shell Script (Example for Bash `COMP_` variables):**
  * `--line "<content of COMP_LINE>"`: The entire current command line.
  * `--word "<content of COMP_WORD[COMP_CWORD]>"`: The current word being completed.
  * `--cword-idx <content of COMP_CWORD>`: The index of the current word.
  * `--point <content of COMP_POINT>`: The current cursor position.
* **Output:** A list of completion strings, one per line, to standard output. These strings are what the shell will display to the user.

## 4. Completion Script Logic (Conceptual for Bash)

While the exact script is generated by `pflow completion <shell_name>`, the conceptual Bash script (`_pflow_completions`) would perform actions similar to this:

```bash
_pflow_completions() {
    # COMP_REPLY is an array of possible completions
    # COMP_LINE is the current command line
    # COMP_WORDS is an array of words in the current command line
    # COMP_CWORD is the index of the current word in COMP_WORDS
    # COMP_POINT is the current cursor position

    local current_word="${COMP_WORDS[COMP_CWORD]}"
    # Invoke pflow to get completions
    # Note: Proper quoting and argument passing is crucial here.
    COMPREPLY=( $(pflow --_pf-autocomplete-generate --line "${COMP_LINE}" --word "${current_word}" --cword-idx "${COMP_CWORD}" --point "${COMP_POINT}" 2>/dev/null) )
    return 0
}

# Register the completion function for the 'pflow' command
complete -F _pflow_completions pflow
```

*Shells like Zsh and Fish have different mechanisms but achieve a similar outcome.*

## 5. `pflow` Internal Completion Logic

A dedicated module/class within `pflow` (e.g., `CompletionHandler`) will be responsible for processing requests from `pflow --_pf-autocomplete-generate`.

### 5.1 Entry Point and Argument Parsing

The main `pflow` CLI application will parse the `--_pf-autocomplete-generate` flag and its arguments, then dispatch to the `CompletionHandler`.

```python
# In pflow's main CLI entry point
# if args.subcommand == "--_pf-autocomplete-generate":
#     handler = CompletionHandler(registry_access_func, metadata_access_func)
#     suggestions = handler.get_completions(
#         line=args.line,
#         current_word=args.word,
#         cword_idx=args.cword_idx,
#         point=args.point
#     )
#     for suggestion in suggestions:
#         print(suggestion)
#     sys.exit(0)
```

### 5.2 `CompletionHandler` Class (Conceptual)

```python
import shlex # For robust command line parsing

class CompletionContext:
    def __init__(self, line, current_word, cword_idx, point):
        self.line = line
        self.current_word = current_word # The word being completed
        self.cword_idx = int(cword_idx)
        self.point = int(point)
        try:
            # shlex.split can handle quoted arguments
            self.words = shlex.split(line_to_cursor) if (line_to_cursor := line[:self.point]) else []
        except ValueError: # Handle incomplete quoting
            self.words = line_to_cursor.split()


        # Determine previous word, current flag, etc.
        self.previous_word = self.words[self.cword_idx - 1] if self.cword_idx > 0 and len(self.words) > self.cword_idx -1 else None
        self.is_completing_flag_value = self.previous_word and self.previous_word.startswith("-")
        self.current_node_name_for_flags = None

        # Simplified logic to find the current node for flag completion
        # This needs to be robust to handle complex pipe scenarios
        # Iterate backwards from current word index to find last non-flag, non-operator word
        if self.cword_idx > 0:
            for i in range(self.cword_idx -1, -1, -1):
                if i < len(self.words) and not self.words[i].startswith("-") and self.words[i] not in ("=>", "-"):
                    # This assumes a simple structure; real parsing might be needed
                    # to confirm it's a valid node name from the registry.
                    if "/" in self.words[i] : # Simple check for namespaced node
                         self.current_node_name_for_flags = self.words[i]
                         break


class CompletionHandler:
    def __init__(self, registry, metadata_loader):
        # registry: An object to query available nodes from the Unified Registry
        # metadata_loader: A function(node_id_with_version) -> NodeMetadata
        self.registry = registry
        self.metadata_loader = metadata_loader

    def get_completions(self, line, current_word, cword_idx, point):
        ctx = CompletionContext(line, current_word, cword_idx, point)
        suggestions = []

        # Scenario 1: Completing the very first word (pflow itself or a command)
        if ctx.cword_idx == 0 : # Actually, shell completion usually handles the command itself
             pass # This part is typically handled by `complete -F _pflow_completions pflow`

        # Scenario 2: Completing after 'pflow' (node name or pflow subcommand)
        if ctx.cword_idx == 1 or (ctx.cword_idx > 1 and ctx.previous_word in ("=>", "-")) or \
           (ctx.cword_idx > 2 and ctx.words[ctx.cword_idx-2] == "-" and ctx.previous_word not in ("=>", "-")): # after 'pflow node - action'
            suggestions.extend(self._suggest_pflow_subcommands())
            suggestions.extend(self._suggest_node_names(ctx))
            # Potentially use Type Shadow Store logic if previous_word was '>>' or an action

        # Scenario 3: Completing after a node name (suggest flags or operators)
        elif ctx.previous_word and not ctx.previous_word.startswith("-") \
             and ctx.previous_word not in ("=>", "-") \
             and "/" in ctx.previous_word: # Simple check it was a node
            suggestions.extend(self._suggest_flags_for_node(ctx.previous_word, ctx))
            suggestions.extend(self._suggest_flow_operators())

        # Scenario 4: Completing after a '-' (suggest action for conditional transition)
        elif ctx.previous_word == "-":
            # Find the node before '-'
            node_before_action = None
            if ctx.cword_idx >= 2 and "/" in ctx.words[ctx.cword_idx - 2]: # Crude check
                 node_before_action = ctx.words[ctx.cword_idx - 2]
            if node_before_action:
                suggestions.extend(self._suggest_actions_for_node(node_before_action, ctx))

        # Scenario 5: Completing a flag value (after --some-flag)
        elif ctx.is_completing_flag_value:
            # previous_word is the flag itself, e.g. --language
            # current_node_name_for_flags is the node this flag belongs to
            if ctx.current_node_name_for_flags:
                 suggestions.extend(self._suggest_values_for_flag(ctx.current_node_name_for_flags, ctx.previous_word, ctx))


        # Filter suggestions based on current_word
        return [s for s in suggestions if s.startswith(current_word)]

    def _suggest_pflow_subcommands(self):
        return ["registry", "trace", "explain", "lock", "run", "completion"] # Add other top-level commands

    def _suggest_node_names(self, ctx: CompletionContext):
        # Access self.registry to get all node IDs
        # Example: node_ids = self.registry.list_all_node_ids_with_versions()
        #
        # This would come from Unified Registry, including MCP wrappers
        #
        # TODO: Implement actual registry query
        all_nodes = ["core/yt-transcript@1.0.0", "core/summarize-text@2.1.0", "mcp/github-search-code@1.2.0"]
        return all_nodes


    def _suggest_flags_for_node(self, node_id_with_version: str, ctx: CompletionContext):
        # node_id_with_version might need parsing if version is optional or resolved.
        # For simplicity, assume full ID is somehow resolved or completion works with partials.
        metadata = self.metadata_loader(node_id_with_version) # Load NodeMetadata
                                                          #
        if not metadata:
            return []

        flags = []
        # Shared store keys from inputs
        # These become data injection flags
        for key_name, key_def in metadata.get("interface", {}).get("inputs", {}).items():
            flags.append(f"--{key_name}")

        # Params
        # These become parameter override flags
        for param_name, param_def in metadata.get("interface", {}).get("params", {}).items():
            flags.append(f"--{param_name}")

        # Standard execution flags (could be global or context-dependent)
        #
        if metadata.get("purity") == "flow_safe" or metadata.get("node",{}).get("properties",{}).get("flow_safe"): # Check @flow_safe
            flags.extend(["--max-retries=", "--wait=", "--use-cache"]) # Allow for @flow_safe nodes

        return flags

    def _suggest_flow_operators(self):
        return ["=>", "-"]

    def _suggest_actions_for_node(self, node_id_with_version: str, ctx: CompletionContext):
        metadata = self.metadata_loader(node_id_with_version)
        if not metadata:
            return []
        # Actions from interface.actions
        actions = metadata.get("interface", {}).get("actions", [])
        return [f'"{action}"' for action in actions if action != "default"] # Quote actions with spaces

    def _suggest_values_for_flag(self, node_id_with_version: str, flag_name: str, ctx: CompletionContext):
        # flag_name includes leading '--'
        param_name = flag_name.lstrip("-")
        metadata = self.metadata_loader(node_id_with_version)
        if not metadata:
            return []

        # Check if it's a known parameter for the node
        param_def = metadata.get("interface", {}).get("params", {}).get(param_name)
        if param_def:
            if param_def.get("type") == "bool" or param_def.get("type") == "boolean":
                return ["true", "false"]
            if "enum" in param_def: # Assuming 'enum' is a list of choices in metadata
                return param_def["enum"]
            # Could add suggestions for 'language' codes, file paths, etc.

        # Check if it's an execution config flag
        if flag_name == "--use-cache":
            return ["true", "false"]
        if flag_name == "--max-retries=" or flag_name == "--wait=": # Value is numeric
            return ["[number]"] # Placeholder

        # For shared store keys, values are usually dynamic, but could suggest common patterns or known values
        # from a Type Shadow Store if one exists and is accessible here.
        #

        return [] # Default: no specific values, user types free-form

    # Placeholder for metadata loading logic
    def _load_node_metadata_via_registry(self, node_id_with_version: str):
        # This function would interact with the pflow registry system
        # to fetch the JSON metadata for a given node ID and version.
        # It should be optimized for performance, potentially using a cache.
        # See for performance architecture.
        # Example structure of metadata is in
        # For this example, returning a mock.
        if node_id_with_version == "core/yt-transcript@1.0.0":
            return {
                "node": {"id": "yt-transcript", "namespace": "core", "version": "1.0.0", "properties": {"flow_safe": True}},
                "interface": {
                    "inputs": {"url": {"type": "str", "required": True, "description": "YouTube video URL"}},
                    "outputs": {"transcript": {"type": "str", "description": "Extracted transcript text"}},
                    "params": {"language": {"type": "str", "default": "en", "enum": ["en", "es", "fr"]}},
                    "actions": ["default", "video_unavailable"]
                }, "purity": "flow_safe" # Duplicating for clarity, one source of truth needed
            }
        if node_id_with_version == "core/summarize-text@2.1.0":
             return {
                "node": {"id": "summarize-text", "namespace": "core", "version": "2.1.0", "properties": {"flow_safe": True}},
                "interface": {
                    "inputs": {"text": {"type": "str", "required": True}},
                    "params": {"temperature": {"type": "float", "default": 0.7}},
                    "outputs": {"summary": {"type": "str"}},
                    "actions": ["default", "content_too_short"]
                }, "purity": "flow_safe"
            }
        return None

# Example instantiation (actual registry/metadata would be injected by pflow app)
# registry_instance = pflow.get_registry()
# metadata_loader_func = pflow.get_metadata_loader()
# completion_handler = CompletionHandler(registry_instance, metadata_loader_func)
```

### 5.3 Parsing Command Line Context

The `CompletionContext` (or similar structure) will be responsible for:

* Tokenizing the input `line` (e.g., using `shlex.split` for shell-like parsing).
* Identifying the word currently being completed (`current_word`).
* Determining the type of token expected at the cursor position (node name, flag, operator, flag value, action).
* Identifying the preceding node if completing an action or the next node in a pipe.
* Identifying the current node if completing its flags or flag values.

This parsing must be robust to handle various `pflow` syntax structures, including multiple piped nodes, parameters, and action-based transitions.

### 5.4 Accessing Registry and Metadata

The `CompletionHandler` will need efficient, read-only access to:

* **The Unified Registry:** To list all available node identifiers (`<namespace>/<name>@<version>`). This includes manually written nodes and MCP wrapper nodes.
* **Node Metadata Cache:** To quickly retrieve the parsed JSON metadata for a given node ID. This metadata contains information about inputs (shared store keys), outputs, parameters, actions, and types. The performance architecture for registry loading should be leveraged here.

## 6. Specific Completion Scenarios and Logic

* **After `pflow` (or `pflow =>` or `pflow some_node - some_action =>`):**
  * Suggest all registered node names/IDs.
  * Suggest `pflow` subcommands (`registry`, `explain`, `run`, `lock`, `trace`, `completion`).
  * If the "Type Shadow Store Prevalidation" logic is accessible, it could filter or rank node suggestions based on compatibility with the previous node's output.
* **After a node name (e.g., `pflow core/yt-transcript@1.0.0`):**
  * Load metadata for `core/yt-transcript@1.0.0`.
  * Suggest `--param_name` for each parameter defined in its metadata.
  * Suggest `--shared_input_key` for each shared store input key defined in its metadata.
  * Suggest execution configuration flags like `--max-retries` (if node is `@flow_safe`).
  * Suggest flow operators: `=>` (for piping) and `-` (for action-based transitions).
* **After a flag (e.g., `pflow core/yt-transcript@1.0.0 --language`):**
  * Load metadata for `core/yt-transcript@1.0.0`.
  * Find the definition for the `language` parameter.
  * If it has predefined values (e.g., an `enum` like `["en", "es", "fr"]` in metadata, or a `boolean` type), suggest those values.
  * Otherwise, no specific value suggestions (user types free-form, or a placeholder like `[string]` could be shown).
* **After `pflow some_node -` (for action-based transition):**
  * Load metadata for `some_node`.
  * Suggest quoted action names from its `interface.actions` list (excluding "default").
* **Filtering:** All suggestions will be filtered by the `current_word` being typed (e.g., if `current_word` is `core/`, only suggest nodes starting with `core/`).

## 7. Performance and Caching

* The completion logic, especially registry access and metadata loading, must be extremely fast to provide a responsive user experience.
* The `pflow` application already has plans for metadata caching and efficient registry loading for the planner. The autocomplete feature should leverage these same mechanisms.
* The `pflow --_pf-autocomplete-generate` call should avoid any expensive initializations if possible, focusing only on the completion task.

## 8. Considerations and Future Enhancements

* **Node Versioning:** Suggestions should ideally include version information or allow completion of versions (e.g., `core/yt-transcript@1.TAB` might suggest `1.0.0`, `1.2.4`). The resolution policy (`@1` -> latest `1.x.x`) could be reflected.
* **Complex CLI Parsing:** Accurately parsing arbitrary partial command lines to determine context can be challenging. The `shlex` module helps, but more sophisticated parsing might be needed for deeply nested or complex scenarios.
* **Quoting:** Suggestions involving spaces (like some action names) must be appropriately quoted for the shell.
* **Contextual Value Suggestions:** For flags expecting shared store keys as input, if a "Type Shadow Store" is active, it could suggest currently available keys in the shared store from previous nodes in the pipe.
* **Descriptions/Help Text:** Future versions could provide brief descriptions alongside suggestions, if the shell's completion system supports it (e.g., Zsh).

This implementation provides a solid foundation for a highly useful CLI autocomplete feature, consistent with `pflow`'s architecture and design goals.

## See Also

- **Architecture**: [CLI Runtime](../features/cli-runtime.md) - CLI parsing and resolution that autocomplete builds on
- **Architecture**: [MVP Implementation Guide](../features/mvp-implementation-guide.md) - Why autocomplete is deferred to v2.0
- **Components**: [Registry](../core-concepts/registry.md) - Node discovery for autocomplete suggestions
- **Components**: [JSON Schemas](../core-concepts/schemas.md) - Metadata format used for completion hints
- **Implementation**: [Metadata Extraction](./metadata-extraction.md) - Source of node interface information
- **Related Features**: [MCP Integration](../features/mcp-integration.md) - MCP node discovery in autocomplete
- **Future Features**: [Components](../architecture/components.md) - Autocomplete in v2.0 component inventory
