# Node Discovery Document Update Plan

**Date**: Current Planning Session  
**Objective**: Rewrite `node-discovery-namespacing-and-versioning.md` to resolve contradictions and integrate with planner architecture  
**Source Analysis**: Based on findings in `node-discovery-contradiction-analysis.md`

---

## Executive Summary

The node discovery document requires comprehensive updates to resolve **5 critical contradictions** and **multiple integration gaps** with the established planner/runtime architecture. This plan outlines specific changes to align the versioning system with the shared store pattern, planner pipeline, and JSON IR structure.

**Key Integration Goals**:
- Resolve IR schema incompatibility (critical)
- Align with planner's node registry and metadata extraction
- Integrate version resolution into planner → compiler → runtime pipeline  
- Maintain kebab-case naming consistency
- Connect versioning with CLI resolution rules

---

## Critical Resolutions Required

### 1. IR Schema Standardization (CRITICAL)

**Current Problem**: Source docs use `{"id": "node-name"}` while discovery uses `{"id": "instance", "type": "namespace/name@version"}`

**Resolution Strategy**: Adopt source document pattern with version integration
```json
{
  "nodes": [
    {"id": "yt-transcript@1.0.0", "params": {"language": "en"}},
    {"id": "summarize-text@2.1.0", "params": {"temperature": 0.7"}}
  ]
}
```

**Alternative**: Extend existing pattern minimally
```json
{
  "nodes": [
    {
      "id": "yt-transcript", 
      "version": "1.0.0",
      "params": {"language": "en"}
    }
  ]
}
```

**Recommendation**: Use the alternative approach to minimize disruption to existing IR schema.

### 2. Planner Pipeline Integration

**Current Problem**: Discovery implies CLI resolution happens before planning

**Resolution**: Position version resolution as planner responsibility
- **Node Discovery**: Planner extracts metadata from versioned nodes
- **Version Selection**: Planner chooses appropriate versions during selection
- **CLI Resolution**: Runtime resolves version shortcuts using planner lockfile

---

## Section-by-Section Update Plan

### Section 1: Identifier Syntax (MINOR UPDATES)

**Status**: Keep core syntax, align naming convention  
**Changes**:
- Change examples to kebab-case: `core/yt-transcript@1.0.0`, `mcp/weather-get@0.3.2`
- Update namespace examples to match source docs
- Ensure consistency with CLI examples throughout document

### Section 2: Resolution Algorithm (MAJOR RESTRUCTURE)

**Status**: Complete rewrite needed  
**New Focus**: Integration with planner pipeline

**New Content**:
```markdown
## 2 · Version Resolution in Planner Pipeline

Resolution occurs in **two phases** aligned with pflow's dual-mode operation:

### 2.1 Natural Language Path
1. **Planner Discovery**: Extract metadata from all installed versions
2. **LLM Selection**: Thinking model chooses nodes AND appropriate versions
3. **IR Generation**: Planner embeds resolved versions in JSON IR
4. **Runtime**: Executes with pinned versions from IR

### 2.2 CLI Pipe Path  
1. **CLI Parsing**: Extract node references with optional version hints
2. **Planner Resolution**: Resolve ambiguous versions using lockfile + policies
3. **Validation**: Ensure selected versions compatible with flow requirements
4. **IR Generation**: Generate IR with resolved versions
```

### Section 3: File-system Layout (KEEP WITH UPDATES)

**Status**: Good structure, align with registry integration  
**Changes**:
- Add note about registry system integration
- Show how planner discovers nodes from filesystem
- Update examples to kebab-case

### Section 4: Installation Workflows (MAJOR UPDATES)

**Status**: Integrate with unified registry approach  
**Changes**:
- Reference unified registry system from MCP integration spec
- Show integration with `pflow registry` commands
- Remove MCP-specific installation (handled by registry system)
- Add planner metadata generation during installation

**New Section Structure**:
```markdown
### 4.1 Manual Node Installation
### 4.2 Registry Integration  
### 4.3 Metadata Generation for Planner
### 4.4 Version Validation
```

### Section 5: Lock-files (COMPLETE RESTRUCTURE)

**Status**: Critical - resolve lockfile purpose confusion  
**New Approach**: Distinguish between version lockfiles and execution lockfiles

**New Content**:
```markdown
## 5 · Lockfile Types and Integration

### 5.1 Version Resolution Lockfile (`flow.versions.lock`)
- **Purpose**: Pin node versions for deterministic planning
- **Generated by**: Planner during initial resolution  
- **Content**: `{"yt-transcript": "1.0.0", "summarize-text": "2.1.0"}`
- **Used by**: Planner for consistent re-resolution

### 5.2 Execution Lockfile (`flow.exec.lock`) 
- **Purpose**: Complete validated IR with signatures
- **Generated by**: Planner after full validation
- **Content**: Complete JSON IR + node versions + flow hash
- **Used by**: Runtime for execution

### 5.3 Relationship
Version lockfile feeds into execution lockfile generation. Version changes trigger re-planning.
```

### Section 6: CLI Grammar (ALIGN WITH SOURCE DOCS)

**Status**: Update to match source document patterns  
**Changes**:
- Use kebab-case in all examples
- Show integration with "Type flags; engine decides" principle
- Demonstrate how version hints work with CLI resolution
- Add examples showing planner validation

**Updated Examples**:
```bash
# Simple flow (planner resolves versions)
pflow yt-transcript --url=X >> summarize-text

# Explicit versioning when needed
pflow yt-transcript@1.0.0 --url=X >> summarize-text@2.1.0

# Mixed shorthand (planner validates compatibility)
pflow yt-transcript --url=X >> summarize-text@2
```

### Section 7: Listing & Search (INTEGRATE WITH REGISTRY)

**Status**: Update to align with registry system  
**Changes**:
- Reference unified `pflow registry` commands
- Show metadata integration with planner
- Update examples to match command structure

### Section 8: Conflict Rules (EXPAND)

**Status**: Add planner integration requirements  
**New Content**:
- How planner handles version conflicts during selection
- Version compatibility validation rules
- Error reporting through planner pipeline

### Section 9: Rationale (UPDATE)

**Status**: Expand to include planner integration benefits  
**New Points**:
- Enables LLM selection across different node versions
- Supports metadata-driven planning with version awareness
- Maintains flow reproducibility through version lockfiles

---

## New Sections to Add

### New Section: Registry Integration with Planner

**Purpose**: Connect filesystem discovery with planner's metadata extraction

**Content**:
```markdown
## X · Registry Integration

### X.1 Planner Discovery Process
1. **Filesystem Scan**: Discover all installed node versions
2. **Metadata Extraction**: Generate planner-compatible metadata from each version
3. **Registry Construction**: Build in-memory registry for LLM selection
4. **Version Filtering**: Present appropriate versions to thinking model

### X.2 Metadata Format Alignment
- Convert namespace/version info to planner metadata schema
- Maintain natural interface documentation
- Preserve version compatibility information
```

### New Section: CLI Integration with Planner

**Purpose**: Show how version resolution integrates with dual-mode CLI operation

**Content**:
```markdown
## Y · CLI Integration Pipeline

### Y.1 Natural Language Path
- User prompt processed by planner
- LLM selects nodes and versions from full registry
- Version resolution transparent to user

### Y.2 CLI Pipe Path  
- Parse CLI syntax for explicit version hints
- Planner validates version compatibility
- Generate version-aware IR for execution
```

---

## Architecture Alignment Changes

### 1. IR Schema Integration

**Update all examples** to use consistent schema:
```json
{
  "nodes": [
    {
      "id": "yt-transcript",
      "version": "1.0.0", 
      "params": {"language": "en"}
    }
  ]
}
```

### 2. Naming Convention Standardization

**Global find/replace**:
- `fetch_url` → `yt-transcript`
- `summarize` → `summarize-text`  
- `save_file` → `store-markdown`
- All snake_case → kebab-case

### 3. Pipeline Integration Points

**Add integration notes** throughout document:
- Where version resolution occurs in planner pipeline
- How metadata extraction works with versioned nodes
- Connection to validation framework
- Relationship with proxy mapping system

---

## Content to Remove

### Remove Conflicting Concepts

1. **Standalone CLI Resolution**: Remove implications that version resolution happens outside planner
2. **Separate Lock Commands**: Remove `pflow lock` as standalone operation
3. **Transport-specific Installation**: MCP installation covered by registry system
4. **IR Schema Examples**: Remove conflicting `{"id": "a", "type": "..."}` examples

### Remove Duplicate Information

1. **Basic CLI Syntax**: Reference source documents instead of duplicating
2. **Shared Store Concepts**: Point to architecture document
3. **Error Handling**: Reference planner spec instead of redefining

---

## Quality Assurance Integration

### Consistency Checks

- [ ] All examples use kebab-case consistently
- [ ] IR schema matches source documents exactly  
- [ ] No conflicts with planner pipeline descriptions
- [ ] Registry concepts align with MCP integration spec
- [ ] CLI resolution follows "Type flags; engine decides" principle

### Integration Validation

- [ ] Version resolution clearly positioned in planner pipeline
- [ ] Metadata extraction connects to planner requirements
- [ ] Lockfile types and purposes clearly distinguished  
- [ ] No contradictions with shared store pattern
- [ ] Natural interface expectations preserved

### Completeness Verification

- [ ] All critical contradictions resolved
- [ ] Integration points with other specs documented
- [ ] Architecture decisions clearly stated
- [ ] Future extensibility preserved

---

## Implementation Priority

### Phase 1: Critical Fixes (Blocking)
1. Resolve IR schema conflict
2. Align naming conventions throughout
3. Position version resolution in planner pipeline
4. Clarify lockfile types and purposes

### Phase 2: Integration (Required for MVP)
1. Add registry integration section
2. Update CLI examples to match source patterns
3. Connect metadata extraction to planner requirements
4. Remove conflicting standalone concepts

### Phase 3: Polish (Post-MVP)
1. Add advanced version selection strategies
2. Enhance error handling integration
3. Optimize metadata caching approaches
4. Expand testing and validation guidance

---

## Success Criteria

1. **Zero Contradictions**: No conflicts with source documents
2. **Clear Integration**: Version resolution role in planner pipeline obvious
3. **Consistent Examples**: All CLI/IR examples match source patterns
4. **Standalone Value**: Document useful without duplicating other specs
5. **Implementation Ready**: Sufficient detail for development

---

## Document Structure Outline (Updated)

```markdown
# Node Discovery, Namespacing & Versioning

## 1 · Identifier Syntax (updated examples)
## 2 · Version Resolution in Planner Pipeline (major rewrite)  
## 3 · File-system Layout (minor updates)
## 4 · Installation & Registry Integration (restructured)
## 5 · Lockfile Types and Integration (complete rewrite)
## 6 · CLI Grammar & Planner Integration (aligned with source)
## 7 · Registry Commands (updated)
## 8 · Conflict Rules & Planner Validation (expanded)
## 9 · Architecture Integration Benefits (updated rationale)
## 10 · Metadata Extraction for Planner (new section)
## 11 · Pipeline Integration Examples (new section)
```

---

**Next Steps**: Implement this plan by systematically rewriting each section according to the specified changes, ensuring all contradictions are resolved and integration points are clearly documented. 