# Claude Code Node Package Specification

> **Prerequisites**: Before implementing or using this node, read the [Node Implementation Reference](../reference/node-reference.md) for common patterns and best practices.

This document specifies the **Claude Code node package** - a powerful super node that integrates with Anthropic's Claude Code CLI in headless mode to provide comprehensive AI-assisted development capabilities with full project context and file system integration.

This is an intentional exception to our [simple node philosophy](../features/simple-nodes.md) - `claude-code` is a "super node" that handles complex development tasks that would require dozens of individual simple nodes. The comprehensive nature and tool integration of Claude Code CLI justifies this architectural decision.

## Node Package Overview

The Claude Code node package provides AI-powered development functionality through a single, sophisticated super node that leverages Claude Code CLI:

| Node | Purpose | Primary Input | Output |
|------|---------|---------------|--------|
| **`claude-code`** | AI-assisted development with comprehensive project context | `prompt` (with generated instructions) | `code_report` (comprehensive development output) |

## Key Differentiation

**Claude Code Super Node vs General LLM Node:**
- **`llm` node**: General text processing with prompts (API-based)
- **`claude-code` node**: Development super node with project context, file access, tool integration, and comprehensive capabilities (CLI-based)

The Claude Code CLI provides:
- Full project understanding and context
- Direct file system access and modification
- Integration with development tools
- Structured, development-specific outputs
- Multi-turn conversation capabilities within project scope

## Claude Code Super Node Specification

### claude-code

**Purpose**: Comprehensive AI-assisted development with context-aware instruction processing

**Interface**:
- Reads: `shared["prompt"]` - comprehensive development instructions (generated by planner)
- Writes: `shared["code_report"]` - complete development output with analysis, implementation, etc.
- Params: `model`, `temperature`, `max_tokens`

**Implementation Notes**:
The claude-code node executes the Claude Code CLI in headless mode, passing comprehensive instructions and extracting structured output including modified files, analysis, and implementation details.

**CLI Examples**:
```bash
# Comprehensive GitHub issue resolution (template-driven workflow)
pflow github-get-issue --issue=1234 => \
  claude-code --prompt="$comprehensive_fix_instructions" => \
  llm --prompt="Write commit message for: $code_report" => \
  git-commit --message="$commit_message"

# Generated instructions example (created by planner)
# $comprehensive_fix_instructions = "Analyze issue #1234, understand the root cause,
# search codebase for relevant files, implement a complete fix with proper error
# handling, write tests, and ensure code quality standards are met..."

# Direct usage with planner-generated instructions
echo "$generated_instructions" | pflow claude-code --temperature=0.2
```

**Parameters**:
- `model` (optional): Claude model (default: claude-3-5-sonnet)
- `temperature` (optional): Creativity level 0.0-1.0 (default: 0.3)
- `max_tokens` (optional): Maximum response length (default: 8192)

## Template-Driven Instruction Generation

The `claude-code` super node receives comprehensive instructions generated by the [planner](../features/planner.md) that combine multiple development tasks into a single, cohesive prompt. This approach provides several advantages:

### Generated Instruction Examples

**Issue Resolution Instructions** (generated by planner with template variables):
```
<instructions>
1. Understand the problem described in the GitHub issue
2. Search the codebase for all relevant files and understand the current implementation
3. Design and implement a complete fix that addresses the issue with proper error handling
4. Write comprehensive tests to verify the fix works correctly
5. Ensure all code follows project standards and passes linting
6. Provide a detailed report of changes made and reasoning behind the approach
</instructions>

This is the issue: $issue
Focus areas for analysis: $focus_areas
Project context: $project_type
```

**Code Quality Instructions** (generated by planner with template variables):
```
<instructions>
1. Analyze the provided code for technical debt, performance issues, and maintainability concerns
2. Refactor the code to improve readability, performance, and follow best practices
3. Ensure all existing functionality is preserved during refactoring
4. Add comprehensive documentation and improve variable/function naming
5. Write tests for any new functionality and verify existing tests still pass
6. Provide a summary of improvements made and their benefits
</instructions>

Code to analyze: $code_content
Focus on: $quality_metrics
Target standards: $coding_standards
```

### Instruction Composition Patterns

The planner generates instructions by composing different development activities based on workflow requirements:

- **Analysis Components**: Root cause analysis, security review, performance assessment
- **Implementation Components**: Code generation, bug fixes, feature development
- **Quality Components**: Code review, testing, documentation, refactoring
- **Integration Components**: File system operations, git commands, build processes

## Template-Driven Workflow Patterns

### Issue Resolution Workflow
```bash
# Template-driven GitHub issue resolution
pflow github-get-issue --issue=1234 => \
  claude-code --prompt="$comprehensive_fix_instructions" => \
  llm --prompt="Write commit message for: $code_report" => \
  git-commit --message="$commit_message" => \
  git-push => \
  github-create-pr --title="Fix: $issue_title" --body="$code_report"

# Where $comprehensive_fix_instructions contains template variables:
# "<instructions>1. Understand the problem...6. Provide detailed report</instructions>
# This is the issue: $issue\nFocus areas: $focus_areas"
```

### Code Quality Improvement
```bash
# Template-driven code quality workflow
pflow github-get-files --path=legacy_module.py => \
  claude-code --prompt="$quality_improvement_instructions" => \
  llm --prompt="Summarize improvements from: $code_report" => \
  write-file --path=REFACTOR_SUMMARY.md --content="$summary"

# Where $quality_improvement_instructions contains template variables:
# "<instructions>1. Analyze code for technical debt...6. Provide summary</instructions>
# Code to analyze: $code_content\nFocus on: $quality_metrics"
```

### Documentation Generation
```bash
# Template-driven documentation workflow
pflow github-get-files --path=api_module.py => \
  claude-code --prompt="$documentation_instructions" => \
  write-file --path=API_DOCS.md --content="$code_report"

# Where $documentation_instructions contains template variables:
# "<instructions>Generate comprehensive API documentation...</instructions>
# Code to document: $api_code\nTarget audience: $audience_level"
```

### Pull Request Review
```bash
# Template-driven PR review workflow
pflow github-get-pr --pr=456 => \
  claude-code --prompt="$pr_review_instructions" => \
  github-add-comment --body="$code_report"

# Where $pr_review_instructions contains template variables:
# "<instructions>Review PR focusing on security and performance...</instructions>
# PR content: $pr_diff\nReview criteria: $review_focus"
```

## Design Principles

### Super Node Architecture
The `claude-code` super node provides comprehensive development capabilities:
- **Unified Interface**: Single node handles all development tasks
- **Context Preservation**: Full project context maintained throughout execution
- **Comprehensive Output**: All results (analysis, implementation, review) in single response
- **Planner-Generated Instructions**: Sophisticated prompts crafted by the planning system

### Template-Driven Interface
The super node uses planner-generated instructions:
- **Sophisticated Prompts**: Complex, context-aware instructions generated by planner
- **Template Variables**: $variable substitution for dynamic content
- **Composite Tasks**: Single instructions combining multiple development activities
- **Context-Aware Generation**: Instructions tailored to specific workflow requirements

### Natural Shared Store Keys

The super node writes to comprehensive shared store keys following the [shared store pattern](../core-concepts/shared-store.md#natural-interfaces):
- `shared["code_report"]` for complete development output
- `shared["analysis"]` for extracted analysis sections
- `shared["implementation"]` for extracted implementation details
- `shared["files_modified"]` for tracking file changes

### Claude Code CLI Integration
The super node leverages the full capabilities of Claude Code CLI:
- **Project Context**: Complete understanding of project structure and history
- **File System Access**: Direct ability to read, analyze, and modify files
- **Tool Integration**: Access to development tools, git, testing frameworks
- **Comprehensive Output**: Structured results covering all aspects of development tasks

## Technical Requirements

### Claude Code CLI Setup
```bash
# Install Claude Code CLI
pip install claude-code-cli

# Authenticate
claude auth login

# Verify installation
claude --version
```

### Environment Variables
- `ANTHROPIC_API_KEY`: API key for Claude access
- `CLAUDE_MODEL`: Default model (optional)
- `CLAUDE_PROJECT_PATH`: Project context path (optional)

### Error Handling
The super node handles Claude Code CLI specific errors:
- Authentication failures
- Model availability
- Context window limits
- File system permissions
- CLI version compatibility
- Instruction parsing failures
- Template variable resolution errors

## Future Extensions

### Enhanced Instruction Generation (v2.0)
- **Adaptive Instructions**: Context-aware instruction modification based on project type
- **Learning from Execution**: Instruction refinement based on execution results
- **Multi-Language Support**: Language-specific instruction templates
- **Team Pattern Integration**: Shared instruction libraries across teams

### Advanced Template Features
- **Conditional Templates**: Instructions that adapt based on context variables
- **Nested Template Variables**: Complex variable substitution patterns
- **Template Validation**: Pre-execution instruction validation
- **Custom Template Libraries**: User-defined instruction templates

### Enhanced Integration
- **IDE Plugin Integration**: Direct Claude Code integration in development environments
- **Git Hook Integration**: Automatic workflow triggers on code changes
- **CI/CD Pipeline Integration**: Automated development tasks in build pipelines
- **Team Collaboration**: Shared workflow templates and execution histories

### Advanced Capabilities
- **Multi-Repository Operations**: Cross-project development tasks
- **Architecture-Level Analysis**: System-wide code analysis and improvements
- **Security Automation**: Automated security review and remediation
- **Performance Intelligence**: AI-driven performance optimization workflows

This Claude Code super node provides comprehensive AI-assisted development capabilities through a unified interface that leverages sophisticated planner-generated instructions and the full power of Claude Code CLI while following proper pocketflow patterns.

## See Also

- **Design Philosophy**: [Simple Nodes Pattern](../features/simple-nodes.md) - Why this is an exception
- **Interface Format**: [Node Metadata Schema](../core-concepts/schemas.md#node-metadata-schema) - How node interfaces are defined
- **Communication**: [Shared Store Pattern](../core-concepts/shared-store.md) - Inter-node data flow
- **Planning System**: [Planner](../features/planner.md) - How template-driven prompts are generated
- **Related Nodes**:
  - [GitHub Nodes](./github-nodes.md) - Issue and PR management nodes
  - [CI Nodes](./ci-nodes.md) - Testing and deployment nodes
  - [LLM Node](./llm-nodes.md) - General text processing (simpler alternative)
