# Subtask 15.3 Handoff: Structure Display Enhancement

**IMPORTANT**: Do not begin implementing yet. Read this entire handoff first and confirm you're ready to begin.

## üéØ Critical Context You Need to Know

### You're Building on Top of 15.1 and 15.2
Both previous subtasks are DONE. This means:
- Workflow loading works (`_load_saved_workflows()` at lines 328-383)
- Two-phase context functions exist (`build_discovery_context()` and `build_planning_context()`)
- **SURPRISE**: Some structure display work already exists! (lines 544-603, 856-942)

### What Already Exists (Check First!)
When implementing 15.2, some structure display functionality was added:
- `_format_structure_combined()` (lines 544-603) - Transforms structures to JSON + paths
- `_format_node_section_enhanced()` (lines 856-904) - Uses enhanced display
- `_add_enhanced_structure_display()` (lines 907-942) - Adds combined format

**YOUR FIRST TASK**: Verify what's already implemented and what's missing!

### The Core Problem You're Solving
The Natural Language Planner needs to generate proxy mappings for incompatible node interfaces:
```json
// When nodes don't connect naturally:
youtube-transcript outputs: shared["transcript"]
llm inputs: shared["prompt"]

// Proxy mapping bridges the gap:
{"prompt": "transcript"}  // Simple mapping
{"author": "issue_data.user.login"}  // Path-based mapping (YOUR FOCUS)
```

Without proper structure display, the planner cannot create these path-based mappings.

### Core Outcomes This Subtask Must Deliver

1. **Verify and Complete Structure Display**:
   - Check if `_format_structure_combined()` fully implements the requirements
   - Ensure it produces BOTH JSON representation AND path list
   - Verify array notation (e.g., `labels[].name`) works correctly
   - Test with `test_node_structured` data

2. **Integration with Planning Context**:
   - Ensure `build_planning_context()` uses the enhanced format for ALL complex types
   - Check that the combined format appears for dict/list outputs
   - Verify the format matches what the planner expects

3. **Refactor Original `_format_structure()`**:
   - Update it to use the combined format
   - Or ensure all callers use the enhanced version
   - Maintain backward compatibility where needed

### üö® Critical Implementation Details

#### Structure Parser (DO NOT MODIFY)
From metadata_extractor.py:
- **Lines 543-612**: Structure parser is FULLY IMPLEMENTED
- **Line 397**: Sets `_has_structure` flag for complex types
- This parser works perfectly - just use its output!

#### Expected Combined Format
From Decision 9 in ambiguities document:
```markdown
**Outputs**:
- `issue_data: dict` - Complete issue data from GitHub API

Structure (JSON format):
```json
{
  "issue_data": {
    "number": "int",
    "title": "str",
    "user": {
      "login": "str",
      "id": "int"
    },
    "labels": [
      {
        "name": "str",
        "color": "str"
      }
    ]
  }
}
```

Available paths:
- issue_data.number (int) - Issue number
- issue_data.title (str) - Issue title
- issue_data.user.login (str) - GitHub username
- issue_data.user.id (int) - User ID
- issue_data.labels[].name (str) - Label name
- issue_data.labels[].color (str) - Label color
```

### Key Decisions Already Made

From `.taskmaster/tasks/task_15/task-15-context-builder-ambiguities.md`:

1. **Structure Display Format** (Decision 9 - CRITICAL):
   - Combined JSON + paths format is MANDATORY
   - JSON shows clean structure (types only, no descriptions)
   - Paths show dot notation with descriptions
   - Both formats together enable accurate proxy mapping

2. **Implementation Requirements**:
   - Transform parser output to dual representation
   - Handle arrays with `[]` notation
   - Preserve descriptions in path list
   - No modifications to the parser itself

3. **Why Combined Format**:
   - LLMs can pattern match from both representations
   - Reduces errors through redundancy
   - Enables direct path copying for mappings
   - Familiar from API documentation patterns

### What You Need to Verify/Implement

1. **Check Existing Implementation**:
   ```python
   # Does _format_structure_combined() produce correct output?
   # Test with this structure:
   structure = {
       "user": {
           "type": "dict",
           "description": "Author information",
           "structure": {
               "login": {"type": "str", "description": "Username"},
               "id": {"type": "int", "description": "User ID"}
           }
       }
   }
   ```

2. **Verify Array Handling**:
   - Does it produce `labels[].name` notation?
   - Are list items handled correctly?
   - Check both "list" and "list[dict]" types

3. **Integration Points**:
   - Is `_format_node_section_enhanced()` used everywhere?
   - Does `build_planning_context()` always show structures?
   - Are all complex types (dict, list) getting enhanced display?

### Essential Context Documents (READ THESE FIRST)

**‚ö†Ô∏è CRITICAL**: Read these Task 15 documents for full context, but remember you're ONLY implementing subtask 15.3:
- `.taskmaster/tasks/task_15/task-15-context-builder-ambiguities.md` - Decision 9 is crucial
- `.taskmaster/tasks/task_15/task-15-technical-implementation-guide.md` - Parser details

These documents cover the ENTIRE Task 15, but you must ONLY:
- Verify/complete structure display enhancement
- Ensure integration with planning context
- Test with complex structures

**DO NOT** implement:
- Workflow loading (done in 15.1)
- Two-phase context functions (done in 15.2)
- Refactoring of `build_context()` (that's subtask 15.4)
- Parser modifications (NEVER touch the parser)

### üß™ CRITICAL: Test-As-You-Go Strategy

**Tests validate your implementation works correctly!**

1. **Create comprehensive structure tests**:
   - Create `tests/test_planning/test_structure_display.py`
   - Test nested dict structures
   - Test list/array handling
   - Test combined format output
   - Use real examples from `test_node_structured`

2. **Structure Format Test Pattern**:
   ```python
   def test_format_structure_combined_nested():
       """Test combined format with nested structures."""
       structure = {
           "issue_data": {
               "type": "dict",
               "description": "GitHub issue",
               "structure": {
                   "number": {"type": "int", "description": "Issue number"},
                   "user": {
                       "type": "dict",
                       "description": "Author info",
                       "structure": {
                           "login": {"type": "str", "description": "Username"}
                       }
                   }
               }
           }
       }

       json_repr, paths = _format_structure_combined(structure["issue_data"]["structure"])

       # Check JSON representation
       assert json_repr == {
           "number": "int",
           "user": {
               "login": "str"
           }
       }

       # Check paths list
       expected_paths = [
           ("number", "int", "Issue number"),
           ("user", "dict", "Author info"),
           ("user.login", "str", "Username")
       ]
       assert paths == expected_paths
   ```

3. **Integration Test Pattern**:
   ```python
   def test_planning_context_shows_structure():
       """Test planning context includes structure display."""
       registry_metadata = {
           "test-node-structured": {
               # Metadata with structure in outputs
           }
       }

       context = build_planning_context(
           ["test-node-structured"], [], registry_metadata
       )

       # Should contain both JSON and paths
       assert "Structure (JSON format):" in context
       assert "Available paths:" in context
       assert "user_data.profile.name" in context
   ```

### Expected Structure Examples

#### Input (from metadata):
```python
{
    "key": "user_data",
    "type": "dict",
    "description": "User information",
    "_has_structure": True,
    "structure": {
        "id": {"type": "str", "description": "User ID"},
        "profile": {
            "type": "dict",
            "description": "User profile",
            "structure": {
                "name": {"type": "str", "description": "Full name"},
                "email": {"type": "str", "description": "Email address"}
            }
        },
        "tags": {
            "type": "list",
            "description": "User tags",
            "items": {"type": "str", "description": "Tag value"}
        }
    }
}
```

#### Expected Output in Planning Context:
```markdown
Structure (JSON format):
```json
{
  "user_data": {
    "id": "str",
    "profile": {
      "name": "str",
      "email": "str"
    },
    "tags": ["str"]
  }
}
```

Available paths:
- user_data.id (str) - User ID
- user_data.profile (dict) - User profile
- user_data.profile.name (str) - Full name
- user_data.profile.email (str) - Email address
- user_data.tags[] (str) - Tag value
```

### Anti-Patterns to Avoid

1. **Don't modify the parser** - It's fragile and working
2. **Don't change existing `_format_structure()`** behavior without checking usage
3. **Don't forget array notation** - Must use `[]` for lists
4. **Don't mix descriptions in JSON** - Keep it clean, types only
5. **Don't create new structure formats** - Use the decided combined format

### What Would Make Me Furious If I Forgot to Mention

1. **The work might be 80% done already** - Check existing functions first!
2. **Test with REAL nodes** - Use `test_node_structured` not made-up examples
3. **Array notation is `[]` not `[0]`** - It represents "any item"
4. **Paths must include parent** - `user_data.profile.name` not just `name`
5. **The JSON wrapper** - Top-level key wraps the structure in JSON display
6. **Integration is key** - Must work with existing planning context

### Performance Considerations

- Structure parsing happens during metadata extraction (already cached)
- Formatting happens at display time (lightweight)
- No need to optimize - correctness matters more than speed
- Modern LLMs handle large contexts easily

### Debugging Tips

1. **Add logging to trace structure flow**:
   ```python
   logger.debug(f"Processing structure for key: {key}")
   logger.debug(f"Structure dict: {structure}")
   ```

2. **Test incrementally**:
   - First test `_format_structure_combined()` alone
   - Then test integration with node formatting
   - Finally test full planning context

3. **Use real test data**:
   - Check what `test_node_structured` actually outputs
   - Use its exact structure format for testing

---

**Remember**: Read all of this first, understand the context, then confirm you're ready to begin implementation. The structure display enhancement you create/complete enables the planner to generate accurate proxy mappings - a critical feature for pflow's success.
