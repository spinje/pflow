# Subtask 14.3 Handoff: Migration to Enhanced Interface Format

**⚠️ IMPORTANT**: Do NOT begin implementing yet. Read this entire handoff and confirm you understand before starting.

## What You're Building On

### The Enhanced Format (from 14.1)
The metadata extractor now parses this enhanced Interface format:

```python
"""
Node description here.

Interface:
- Reads: shared["key"]: type  # Description
    - field1: type  # For nested structures
    - field2: type  # Another field
- Writes: shared["key"]: type  # Description
- Params: param: type  # Description (default: value)
- Actions: default, error (on failure)
"""
```

**CRITICAL**: The parser is ALREADY DONE in `src/pflow/registry/metadata_extractor.py`. You're just updating nodes to use this format.

### The Context Builder (from 14.2)
I just updated the context builder to display ALL descriptions in verbose format:

```markdown
**Outputs**: `issue_data: dict` - Issue information
  Structure of issue_data:
    - number: int - Issue number
    - title: str - Issue title
    - user: dict - Author information
      - login: str - GitHub username
      - id: int - User ID
```

This means **descriptions at EVERY level** are now shown to the planner.

## Current State of Nodes

### Existing Nodes to Update
All nodes in `src/pflow/nodes/` currently use the SIMPLE format:

```python
# Current simple format:
Interface:
- Reads: shared["file_path"] (required), shared["encoding"] (optional)
- Writes: shared["content"] on success, shared["error"] on failure
- Params: file_path, encoding (as fallbacks if not in shared)
- Actions: default (success), error (failure)
```

Files that need updating:
- `/src/pflow/nodes/file/read_file.py`
- `/src/pflow/nodes/file/write_file.py`
- `/src/pflow/nodes/file/copy_file.py`
- `/src/pflow/nodes/file/move_file.py`
- `/src/pflow/nodes/file/delete_file.py`
- `/src/pflow/nodes/test_node.py`
- `/src/pflow/nodes/test_node_retry.py`

### Critical Pattern to Preserve

**⚠️ DO NOT BREAK THE RETRY PATTERN!**

All nodes inherit from `Node` (not `BaseNode`) and follow a specific error handling pattern. See `/src/pflow/nodes/CLAUDE.md` for the critical pattern. The key points:

1. **NO try/except in exec()** - Let exceptions bubble up for retry
2. **Return only success values from exec()**
3. **Handle errors in exec_fallback()** after retries
4. **Check for errors in post()** by looking for "Error:" prefix

Your Interface documentation changes should NOT touch the actual code logic!

## The Exact Format to Follow

### For Simple Types
```python
- Reads: shared["file_path"]: str  # Path to the file to read
         shared["encoding"]: str  # File encoding (optional)
```

### For Complex Types with Structures
```python
- Writes: shared["issue_data"]: dict  # GitHub issue information
    - number: int  # Issue number
    - title: str  # Issue title
    - user: dict  # Author information
      - login: str  # GitHub username
      - id: int  # User ID
    - labels: list  # Issue labels
```

### For Parameters with Defaults
```python
- Params: encoding: str  # File encoding (default: utf-8)
          overwrite: bool  # Whether to overwrite existing files (default: False)
```

### Actions Format (unchanged)
```python
- Actions: default (success), error (failure)
```

## Priority Nodes and Special Cases

The task mentions starting with priority nodes:
1. **github-get-issue** - Most complex with nested structures
2. **github-list-prs** - Has arrays

**HOWEVER**: I don't see these nodes implemented yet! They might be planned for Task 13. For now, focus on the file nodes that exist.

### File Node Considerations

For file operations, consider documenting:
- Error types that can occur (FileNotFoundError, PermissionError, etc.)
- Any metadata structures (file stats, etc.)
- Security considerations already mentioned in docstrings

## Examples to Update

The task also mentions updating examples in `examples/` folder. These JSON files demonstrate workflows and need to show the new typed interfaces.

Current examples use nodes like:
- `csv-reader`
- `sentiment-analyzer`
- `report-generator`

These nodes don't exist yet, so you might need to:
1. Update examples to use the actual file nodes that exist
2. Or skip example updates if they reference non-existent nodes
3. Or create placeholder enhanced Interface docs for the example nodes

## Testing Your Updates

After updating each node:

1. **Run the metadata extractor** to verify parsing:
```python
from pflow.registry.metadata_extractor import PflowMetadataExtractor
from src.pflow.nodes.file.read_file import ReadFileNode

extractor = PflowMetadataExtractor()
metadata = extractor.extract_metadata(ReadFileNode)
print(metadata)
```

2. **Check the context builder output**:
```python
from pflow.planning.context_builder import build_context
# ... test with your updated nodes
```

3. **Run existing tests** - Make sure nothing breaks:
```bash
make test
```

## Patterns and Pitfalls

### ✅ DO:
- Keep descriptions concise but informative
- Use consistent terminology (e.g., "Path to the file" not "File path")
- Document optional vs required clearly
- Add type for EVERY field, even if it's `any`
- Preserve all existing functionality notes (security warnings, etc.)

### ❌ DON'T:
- Change the code logic (only update docstrings)
- Break the retry pattern
- Add descriptions that are too verbose
- Forget to test parsing after each update
- Mix simple and enhanced format in one Interface

## The Exclusive Params Pattern

Remember from the knowledge base: Parameters that are also inputs should NOT be shown as parameters in the context. The context builder already handles this, but make sure your enhanced format preserves this behavior.

For example, if `file_path` is both in Reads and Params (as a fallback), it should only show in Inputs in the final context.

## Format Detection Insight

The parser detects format by looking for colons after keys:
- `shared["key"]: type` → Enhanced format
- `shared["key"]` → Simple format

It then normalizes everything to rich format internally.

## Final Critical Reminder

This is mostly a **documentation task**. You're updating docstrings to use the enhanced format. The parser and context builder are already done. Don't overcomplicate it!

The goal is to make all nodes provide rich type information and descriptions so the planner can:
1. Understand data types
2. Know how to access nested structures
3. Generate valid proxy mappings

Good luck! Remember to read everything before starting implementation.

---

**Remember**: Do NOT begin implementing yet. Read this handoff, check the referenced files, and confirm you understand the task before starting.
