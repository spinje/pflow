# Subtask 14.3 Handoff: The Great Migration (Reality Edition)

**⚠️ IMPORTANT**: Do NOT begin implementing yet. Read this entire handoff and confirm you understand before starting.

## The Reality Check

You're inheriting a FULLY FUNCTIONAL enhanced metadata system:
- **14.1**: Built the parser that extracts types, structures, and descriptions
- **14.2**: Updated the context builder to display everything beautifully

The system is ALREADY converting old format nodes to rich format with defaults:
```python
# Old format in docstring:
Writes: shared["content"], shared["error"]

# Becomes this in metadata:
[
  {"key": "content", "type": "any", "description": ""},
  {"key": "error", "type": "any", "description": ""}
]
```

Your job: Give nodes REAL types and descriptions so the planner can do its magic.

## CRITICAL: Task 13 Not Implemented Yet!

The task description mentions GitHub nodes as priority, but **Task 13 (platform nodes) hasn't been implemented yet**. This means:
- No GitHub nodes exist
- No Git/CI/Shell nodes exist
- No LLM or Claude Code nodes exist

**What DOES exist:**
- `/src/pflow/nodes/file/read_file.py`
- `/src/pflow/nodes/file/write_file.py`
- `/src/pflow/nodes/file/copy_file.py`
- `/src/pflow/nodes/file/move_file.py`
- `/src/pflow/nodes/file/delete_file.py`
- `/src/pflow/nodes/test_node.py`
- `/src/pflow/nodes/test_node_retry.py`

So you'll be migrating these 7 nodes only!

## The Exact Format You Must Use

### Simple Types (What You'll Use Most)
```python
"""
Interface:
- Reads: shared["file_path"]: str  # Path to the file to read
- Writes: shared["content"]: str, shared["error"]: str  # File contents or error message
- Params: encoding: str  # File encoding (default: utf-8)
- Actions: default (success), error (failure)
"""
```

### Multiple Reads/Writes on Separate Lines
```python
"""
Interface:
- Reads: shared["source_path"]: str  # Source file path
- Reads: shared["dest_path"]: str  # Destination file path
- Writes: shared["copied"]: bool  # True if copy succeeded
- Writes: shared["error"]: str  # Error message on failure
"""
```

### Key Format Rules (CRITICAL)
1. **Type goes after colon**: `shared["key"]: type` or `param: type`
2. **Description after #**: `# This explains what it is`
3. **Multiple outputs on one line**: Use commas if they share description
4. **Separate lines**: Use when different descriptions needed
5. **Keep it simple**: File nodes don't have complex structures

## Migration Order for Existing Nodes

### Phase 1: Core File Operations
Start with the most used nodes:

1. **read-file** (`src/pflow/nodes/file/read_file.py`)
   - Already has Interface, just add types
   - Show good descriptions for common operation

2. **write-file** (`src/pflow/nodes/file/write_file.py`)
   - Has multi-line Reads section
   - Good example of multiple inputs

3. **copy-file** (`src/pflow/nodes/file/copy_file.py`)
   - Simple source/dest pattern
   - Boolean success output

### Phase 2: File Manipulation
4. **move-file** (`src/pflow/nodes/file/move_file.py`)
   - Has 3-line Writes section (moved, error, warning)
   - Shows multiple output handling

5. **delete-file** (`src/pflow/nodes/file/delete_file.py`)
   - Safety parameters (confirm_delete)
   - Security considerations

### Phase 3: Test Nodes
6. **test-node** (`src/pflow/nodes/test_node.py`)
7. **test-node-retry** (`src/pflow/nodes/test_node_retry.py`)
   - Might be minimal or have special patterns

## Critical Pattern to Preserve

**⚠️ DO NOT BREAK THE RETRY PATTERN!**

All nodes inherit from `Node` (not `BaseNode`) and follow a specific error handling pattern. The key points:

1. **NO try/except in exec()** - Let exceptions bubble up for retry
2. **Return only success values from exec()**
3. **Handle errors in exec_fallback()** after retries
4. **Check for errors in post()** by looking for "Error:" prefix

Your Interface documentation changes should NOT touch the actual code logic!

## What NOT to Change

1. **Don't Touch the Parser** - It's in `metadata_extractor.py` and it's perfect
2. **Don't Modify Tests Yet** - They already expect rich format
3. **Don't Change Context Builder** - 14.2 already did that
4. **Don't Add New Features** - Just document what exists
5. **Don't Touch Node Logic** - Only update docstrings!

## Testing Your Changes

After updating each node:

1. **Quick Parser Test**:
   ```python
   from pflow.registry.metadata_extractor import PflowMetadataExtractor
   from src.pflow.nodes.file.read_file import ReadFileNode

   extractor = PflowMetadataExtractor()
   metadata = extractor.extract_metadata(ReadFileNode)
   print(metadata)  # Should show your types and structures
   ```

2. **Run Existing Tests**:
   ```bash
   make test  # Ensure nothing breaks
   ```

3. **Look for These in Metadata**:
   - Types showing: `{"key": "file_path", "type": "str", "description": "Path to the file"}`
   - All inputs/outputs have types
   - Descriptions are clear and helpful

## Migration Cookbook for File Nodes

### Pattern 1: Simple Read Operation
```python
# OLD:
"""
Interface:
- Reads: shared["file_path"] (required), shared["encoding"] (optional)
- Writes: shared["content"] on success, shared["error"] on failure
"""

# NEW:
"""
Interface:
- Reads: shared["file_path"]: str  # Path to the file to read
- Reads: shared["encoding"]: str  # File encoding (optional, default: utf-8)
- Writes: shared["content"]: str, shared["error"]: str  # File contents or error message
"""
```

### Pattern 2: File Manipulation
```python
# OLD:
"""
Interface:
- Reads: shared["source_path"] (required), shared["dest_path"] (required), shared["overwrite"] (optional)
- Writes: shared["moved"] on success, shared["error"] on failure, shared["warning"] if needed
"""

# NEW:
"""
Interface:
- Reads: shared["source_path"]: str  # Source file path
- Reads: shared["dest_path"]: str  # Destination file path
- Reads: shared["overwrite"]: bool  # Whether to overwrite existing files (optional)
- Writes: shared["moved"]: bool  # True if move succeeded
- Writes: shared["error"]: str  # Error message on failure
- Writes: shared["warning"]: str  # Warning message if applicable
"""
```

## Common Pitfalls to Avoid

1. **Wrong Type Syntax**
   ```python
   # WRONG:
   shared["key"] : str  # Space before colon
   shared["key"]: String  # Wrong type name
   shared["key"]: (str)  # Parentheses

   # RIGHT:
   shared["key"]: str
   ```

2. **Params That Are Inputs**
   ```python
   # If file_path is in Reads, it might also be in Params as fallback
   # Document both - the context builder filters automatically
   ```

3. **Over-Documenting**
   ```python
   # Keep descriptions concise and useful
   # Bad: "The path to the file that will be read by this node"
   # Good: "Path to the file to read"
   ```

## Examples Folder Considerations

The `examples/` folder might reference nodes that don't exist yet (like github nodes). You have options:

1. **Skip example updates** if they reference non-existent nodes
2. **Update examples to use file nodes** that actually exist
3. **Document the issue** for when platform nodes are implemented

## The Semantic Description Guidelines

Good descriptions help the planner understand:

1. **What It Represents**: "Path to the file" not just "string"
2. **Optional vs Required**: Note in description
3. **Defaults**: "default: utf-8"
4. **Purpose**: "for reading", "to write", etc.

Examples:
```python
- file_path: str  # Path to the file to read
- encoding: str  # File encoding (optional, default: utf-8)
- overwrite: bool  # Whether to overwrite existing files (default: false)
- content: str  # File contents
- error: str  # Error message if operation failed
```

## The Exclusive Params Pattern

Remember: Parameters that are also inputs should NOT be shown as parameters in the context. The context builder already handles this filtering. For file nodes, this commonly applies to:
- `file_path` (often both input and param)
- `encoding` (often both input and param)

## Your Success Metrics

When you're done:
1. All 7 existing nodes have typed Interface sections
2. Every field has a type (even if it's `any`)
3. Descriptions are clear and helpful
4. Parser successfully extracts all your documentation
5. All existing tests still pass
6. Metadata shows rich format for all nodes

## Quick Reference Card

```python
# Types to use:
str      # Text/strings (file paths, content, errors)
int      # Whole numbers (rarely used in file ops)
bool     # True/False (success flags, options)
any      # When type varies (avoid if possible)

# Format checklist:
✓ Colon after key: shared["key"]: type
✓ Space after colon
✓ # for descriptions
✓ Consistent terminology
✓ Note optional/defaults
```

## Final Critical Reminders

1. **You're Not Debugging** - The system works, you're adding content
2. **Only 7 Nodes** - Don't look for nodes that don't exist
3. **Test Each Node** - Verify parsing after each update
4. **Preserve Functionality** - Don't break the retry pattern
5. **This is Foundation Work** - When platform nodes come, they'll follow your pattern

The parser and context builder teams did the hard work. You're adding the content that makes file operations clear to the planner. While you won't have complex structures to document, your clear types and descriptions set the standard for future nodes.

---

**Remember**:
- Read the project context (`.taskmaster/tasks/task_14/project-context.md`) for domain understanding
- The enhanced parser in 14.1 defines the exact format
- The context builder in 14.2 shows how it's displayed
- Your job is content, not code
- Only work with nodes that actually exist!

Good luck with the migration!
