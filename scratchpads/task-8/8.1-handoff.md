# Subtask 8.1 Handoff: Create shell_integration.py with dual-mode stdin handling

**TO THE IMPLEMENTING AGENT**: Read this entire memo before starting. When done, acknowledge you're ready to begin - DO NOT start implementing immediately.

## ğŸš¨ Critical Context You Need to Know

### The Hidden Validation Trap (Lines 52-55)
The current CLI has validation that **blocks stdin when command args are provided**. This is THE core blocker for dual-mode stdin:
```python
if workflow:
    raise click.ClickException(
        "cli: Cannot use stdin input when command arguments are provided..."
    )
```

**Why this matters**: The entire dual-mode design depends on bypassing this validation ONLY when appropriate. Don't just delete it - you need to be surgical. The validation should remain for `echo workflow | pflow some-args` but NOT for `cat data | pflow --file workflow.json`.

### The Magic Line 89
In `src/pflow/cli/main.py`, line 89 is where `shared_storage` is created. This is your **only clean injection point** for stdin data. Everything before this is workflow loading/validation. Everything after expects the shared store to be ready.

### stdin Already Works (Sort Of)
The CLI already detects stdin with `not sys.stdin.isatty()` and reads it. But it treats ALL stdin as workflow input. Your job is to make it smarter - sometimes it's workflow, sometimes it's data.

## ğŸ¯ Core Outcomes This Subtask MUST Achieve

1. **A standalone module** at `src/pflow/core/shell_integration.py` that can:
   - Detect if stdin is piped (already exists in CLI, but centralize it)
   - Read stdin safely with proper encoding
   - **Determine if content is workflow or data** (check for `"ir_version"`)
   - Populate shared store with stdin data

2. **Keep it simple** - This subtask is ONLY the utilities. Don't modify the CLI yet. That's subtask 8.2's job.

## ğŸ’£ Landmines I Discovered

### Empty stdin vs No stdin
Click's CliRunner (used in tests) makes stdin look piped even when empty. Real shell behaves differently. Your code needs to handle:
- No stdin (interactive terminal)
- Empty stdin (echo "" | pflow)
- Actual stdin content

Test like this:
```python
content = read_stdin()
if content == "":  # Empty but piped
    return None  # Treat as no input
```

### Binary Detection Gotcha
Don't try to detect binary in this subtask. Keep it text-only for now. Binary support comes in subtask 8.4. If you try to handle both now, you'll overcomplicate the module.

### The Import Trap
When the CLI imports your module, it should NOT have side effects. Don't read stdin on import. All functions should be explicit calls.

## ğŸ” Patterns to Follow

### From Task 11 (File Nodes)
They use this error pattern:
```python
def exec(self, shared):
    try:
        # operation
        return "default", True
    except Exception as e:
        return "error", False
```

Your module doesn't need exec/post/prep (it's not a node), but follow their error handling style - explicit and predictable.

### From Knowledge Base
The Click validation pattern - we discovered stdin detection must handle CliRunner's quirks. Check for actual content, not just `isatty()`.

## ğŸ”— Essential Files to Read

1. **Current stdin handling**: `src/pflow/cli/main.py` lines 38-60 (get_input_source function)
2. **Node patterns**: Any file in `src/pflow/nodes/file/` for style consistency
3. **Research goldmine**: `.taskmaster/tasks/task_8/research/stdin-handling-patterns.md` - Has TONS of code examples

## âš¡ Quick Implementation Checklist

```python
# Your module structure:
def detect_stdin() -> bool:
    """Check if stdin is piped."""
    return not sys.stdin.isatty()

def read_stdin() -> str | None:
    """Read stdin content if available."""
    if not detect_stdin():
        return None
    content = sys.stdin.read().strip()
    return content if content else None  # Handle empty stdin

def determine_stdin_mode(content: str) -> str:
    """Determine if stdin contains workflow or data."""
    try:
        data = json.loads(content)
        if isinstance(data, dict) and "ir_version" in data:
            return "workflow"
    except json.JSONDecodeError:
        pass
    return "data"

def populate_shared_store(shared: dict, content: str) -> None:
    """Add stdin content to shared store."""
    shared["stdin"] = content
```

## ğŸ§ª Test Patterns That Work

```python
# Mock stdin for tests
import io
from unittest.mock import patch

def test_with_piped_stdin():
    with patch('sys.stdin', io.StringIO('test data')):
        with patch('sys.stdin.isatty', return_value=False):
            content = read_stdin()
            assert content == 'test data'
```

## ğŸš€ What Success Looks Like

When you're done, another dev should be able to:
```python
from pflow.core.shell_integration import read_stdin, determine_stdin_mode

content = read_stdin()
if content:
    mode = determine_stdin_mode(content)
    if mode == "data":
        # This is what enables the magic
        shared["stdin"] = content
```

## âŒ What NOT to Do

1. **Don't modify the CLI** - That's subtask 8.2
2. **Don't implement streaming** - That's subtask 8.4
3. **Don't handle binary** - Keep it simple, text only
4. **Don't add Click dependencies** - This is a pure utility module
5. **Don't implement output handling** - That's subtask 8.5

## ğŸ“ Final Notes

- The research files have WAY more examples than you need. Focus on the "Basic Read" and "Smart Population" sections
- Simon Willison's patterns are overkill for this subtask. Save those for later
- Type hints are your friend - use them everywhere
- Remember: empty string != None. This distinction matters for stdin

**Most importantly**: This module is the foundation. Keep it clean, testable, and focused. The fancy stuff comes later.

---

**REMEMBER**: Acknowledge you've read this and are ready to begin. Do not start implementing until you've understood everything above.
