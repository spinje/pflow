Implementation Briefing for Subtask 4.2: Dynamic Node Import System

  Your Foundation (From 4.1)

  You're building on a solid foundation created in subtask 4.1:
  - src/pflow/runtime/compiler.py exists with compile_ir_to_flow() function
  - CompilationError class with rich context (phase, node_id, node_type, details, suggestion)
  - Helper functions: _parse_ir_input() and _validate_ir_structure()
  - Structured logging pattern with phase tracking
  - All using traditional functions (NOT PocketFlow orchestration)

  Your Mission

  Create the dynamic import system that takes node types from the IR and loads the actual Python classes using registry metadata. This
  is the bridge between node names in JSON and executable Python classes.

  Critical Context

  What You're Building

  A helper function import_node_class(node_type: str, registry: Registry) -> Type[BaseNode] that:
  1. Looks up metadata in the registry
  2. Dynamically imports the Python module
  3. Gets the class from the module
  4. Verifies it's a valid BaseNode subclass
  5. Returns the class (not an instance!)

  Registry Format (From Task 5)

  The registry provides metadata ONLY - never class references:
  # Registry data structure (simplified)
  {
      "read-file": {
          "module": "pflow.nodes.file_nodes",
          "class_name": "ReadFileNode",
          "description": "Reads file content",
          # ... other metadata
      }
  }

  Key Architectural Decision

  We're using traditional functions, not PocketFlow nodes. This was decided because the compiler is a simple transformation without
  retry needs or I/O operations.

  Implementation Pattern

  Core Function Structure

  def import_node_class(node_type: str, registry: Registry) -> Type[BaseNode]:
      """Import and validate a node class from registry metadata.

      Args:
          node_type: The node type identifier (e.g., "read-file")
          registry: Registry instance containing node metadata

      Returns:
          The node class (not instance) ready for instantiation

      Raises:
          CompilationError: With specific error context
      """
      # Your implementation here

  Error Handling Hierarchy

  You'll handle three types of errors, each with specific context:

  1. Missing from Registry
    - Error: node_type not found in registry
    - Phase: "node_resolution"
    - Include available node types in suggestion
  2. Import Failures
    - ImportError: Module doesn't exist
    - Phase: "node_import"
    - Include the module path attempted
  3. Class Issues
    - AttributeError: Class doesn't exist in module
    - Phase: "node_import"
    - Include class_name attempted
  4. Inheritance Issues
    - TypeError/other: Class doesn't inherit from BaseNode
    - Phase: "node_validation"
    - Include what it actually inherits from

  Implementation Steps

  1. Registry Lookup
  # Get all nodes from registry
  nodes = registry.load()  # Returns dict[str, dict]

  # Check if node_type exists
  if node_type not in nodes:
      # Build helpful error with suggestions
  2. Dynamic Import
  import importlib

  module_path = nodes[node_type]["module"]
  module = importlib.import_module(module_path)
  3. Class Extraction
  class_name = nodes[node_type]["class_name"]
  node_class = getattr(module, class_name)
  4. Inheritance Verification
  from pocketflow import BaseNode

  if not issubclass(node_class, BaseNode):
      # Not a valid node class

  Structured Logging

  Follow the pattern from 4.1:
  logger.debug("Looking up node in registry", extra={
      "phase": "node_resolution",
      "node_type": node_type
  })

  Testing Strategy

  Test File: tests/test_compiler_dynamic_imports.py

  Mock Patterns

  from unittest.mock import Mock, patch

  # Mock a valid node class
  mock_node_class = type('MockNode', (BaseNode,), {})

  # Mock importlib
  with patch('pflow.runtime.compiler.importlib.import_module') as mock_import:
      mock_module = Mock()
      mock_module.MockNode = mock_node_class
      mock_import.return_value = mock_module

  Test Cases You Must Cover

  1. Success Case
    - Valid node type → successful import → returns class
  2. Registry Miss
    - Unknown node type → CompilationError with suggestions
  3. Import Errors
    - Module not found → CompilationError with module path
    - Use side_effect=ImportError("No module named 'x'")
  4. Class Not Found
    - Module exists but class missing → CompilationError
    - Mock module without the expected attribute
  5. Invalid Inheritance
    - Class exists but not BaseNode → CompilationError
    - Create mock class without BaseNode inheritance
  6. Integration Test
    - Use actual test node from src/pflow/nodes/test_node.py
    - Verify real-world import works

  Common Pitfalls to Avoid

  1. Don't instantiate the class - Return the class itself, not an instance
  2. Don't catch Exception broadly - Handle specific errors (ImportError, AttributeError)
  3. Don't forget logging - Every major step should log with phase context
  4. Don't return None - Always raise CompilationError on failure

  Integration Points

  How 4.3 Will Use Your Function

  # In subtask 4.3, they'll do:
  for node in ir_dict["nodes"]:
      node_class = import_node_class(node["type"], registry)
      instance = node_class()  # They instantiate
      if "params" in node:
          instance.set_params(node["params"])

  Error Message Quality

  Your errors must be actionable. Examples:
  - ❌ "Import failed"
  - ✅ "Failed to import module 'pflow.nodes.custom': No module named 'custom'"

  Success Checklist

  - Function handles all 4 error types with proper CompilationError
  - Each error includes phase, context, and helpful suggestion
  - Structured logging at each step
  - Returns class, not instance
  - All tests pass including real import test
  - No broad exception catching
  - Follows existing patterns from 4.1

  Quick Reference

  - Registry method: registry.load() returns dict[str, dict]
  - Import: importlib.import_module(module_path)
  - Get class: getattr(module, class_name)
  - Check inheritance: issubclass(cls, BaseNode)
  - BaseNode import: from pocketflow import BaseNode

  Remember: You're building one focused function that does dynamic imports really well. Keep it simple, test it thoroughly, and make
  errors helpful for debugging.
