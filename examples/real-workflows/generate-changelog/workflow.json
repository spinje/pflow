{
  "inputs": {
    "since_tag": {
      "type": "string",
      "required": false,
      "default": "",
      "description": "Tag to start from (default: latest tag)"
    },
    "changelog_file": {
      "type": "string",
      "required": false,
      "default": "CHANGELOG.md",
      "description": "Path to markdown changelog file"
    },
    "mintlify_file": {
      "type": "string",
      "required": false,
      "default": "docs/changelog.mdx",
      "description": "Path to Mintlify changelog (pass empty string to skip)"
    },
    "releases_dir": {
      "type": "string",
      "required": false,
      "default": "releases",
      "description": "Directory for release context files"
    }
  },
  "nodes": [
    {
      "id": "get-latest-tag",
      "type": "git-get-latest-tag",
      "purpose": "Get latest git tag as baseline"
    },
    {
      "id": "resolve-tag",
      "type": "shell",
      "purpose": "Use provided tag or default to latest",
      "params": {
        "command": "provided='${since_tag}'\nlatest='${get-latest-tag.latest_tag.name}'\nif [ -n \"$provided\" ]; then echo \"$provided\"; else echo \"$latest\"; fi | tr -d '\\n'"
      }
    },
    {
      "id": "get-docs-diff",
      "type": "shell",
      "purpose": "Get documentation changes since tag, grouped by file with commit refs",
      "params": {
        "command": "tag='${resolve-tag.stdout}'\nfor file in $(git diff \"$tag\"..HEAD --name-only -- docs/ 2>/dev/null | command grep -v changelog.mdx); do\n  echo \"## $file\"\n  echo \"Commits: $(git log \"$tag\"..HEAD --oneline -- \"$file\" | paste -sd ', ' -)\"\n  echo \"Changes:\"\n  git diff \"$tag\"..HEAD -- \"$file\" | command grep '^[+-]' | command grep -v -E '^\\+\\+\\+|^---' | head -50\n  echo \"\"\ndone"
      }
    },
    {
      "id": "get-recent-updates",
      "type": "shell",
      "purpose": "Get last 2 Update blocks from changelog as style reference",
      "params": {
        "command": "awk '/<Update/,/<\\/Update>/{print; if(/<\\/Update>/){count++; if(count==2) exit}}' docs/changelog.mdx 2>/dev/null || echo ''"
      }
    },
    {
      "id": "get-commits-enriched",
      "type": "shell",
      "purpose": "Fetch commits since tag with PR metadata, file paths, and task numbers",
      "params": {
        "command": "tag='${resolve-tag.stdout}'\nrepo=$(gh repo view --json nameWithOwner -q '.nameWithOwner')\n\n# Get commits with file stats\ncommits=$(git log --first-parent \"$tag\"..HEAD --format='COMMIT_START%n{\"hash\":\"%H\",\"commit_message\":\"%s\"}%nCOMMIT_END' | \\\n  awk '/COMMIT_START/{getline json; getline; print json}' | jq -s '.')\n\n# Get file changes per commit\nfile_changes=$(git log --first-parent \"$tag\"..HEAD --format='HASH:%H' --name-only | \\\n  awk '/^HASH:/{hash=substr($0,6); next} NF{files[hash]=files[hash] $0 \",\"} END{for(h in files) print h \"|\" files[h]}' | \\\n  jq -Rs 'split(\"\\n\") | map(select(length>0) | split(\"|\") | {key: .[0], value: (.[1] // \"\" | split(\",\") | map(select(length>0)) | join(\", \"))}) | from_entries')\n\n# Get PRs\nprs=$(gh pr list --state merged --limit 200 --json number,title,body 2>/dev/null || echo '[]')\n\n# Combine all data\necho \"$commits\" | jq --argjson prs \"$prs\" --argjson files \"$file_changes\" --arg repo \"$repo\" '\n  map(. + {\n    pr_number: null, pr_title: \"\", pr_body: \"\", pr_link: \"\", is_merge: false,\n    files_changed: ($files[.hash] // \"\"),\n    task_number: null\n  } |\n  # Extract task number from commit message or PR body\n  (if .commit_message | test(\"[Tt]ask[- ]?[0-9]+\") then\n    (.commit_message | capture(\"[Tt]ask[- ]?(?<num>[0-9]+)\").num | tonumber)\n  else null end) as $task_from_commit |\n  . + {task_number: $task_from_commit} |\n  # Enrich with PR data\n  if .commit_message | test(\"^Merge pull request #[0-9]+\") then\n    (.commit_message | capture(\"#(?<num>[0-9]+)\").num | tonumber) as $prnum |\n    ($prs | map(select(.number == $prnum)) | first // {}) as $pr |\n    (if ($pr.body // \"\") | test(\"[Tt]ask[- _]?[0-9]+\") then\n      (($pr.body // \"\") | capture(\"[Tt]ask[- _]?(?<num>[0-9]+)\").num | tonumber)\n    else .task_number end) as $task_from_pr |\n    . + {\n      pr_number: $prnum,\n      pr_title: ($pr.title // \"\"),\n      pr_body: ($pr.body // \"\"),\n      pr_link: \"https://github.com/\\($repo)/pull/\\($prnum)\",\n      is_merge: true,\n      task_number: ($task_from_pr // .task_number)\n    }\n  elif .commit_message | test(\"\\\\(#[0-9]+\\\\)\") then\n    (.commit_message | capture(\"\\\\(#(?<num>[0-9]+)\\\\)\").num | tonumber) as $prnum |\n    . + {pr_number: $prnum, pr_link: \"https://github.com/\\($repo)/pull/\\($prnum)\"}\n  else . end\n  # Add pr_summary (truncated for classification)\n  | . + {pr_summary: (if .pr_body and (.pr_body | length) > 0 then (.pr_body | split(\"\\n## \") | map(select(startswith(\"Summary\"))) | first // \"\") | split(\"\\n\\n\")[0:2] | join(\"\\n\\n\") | .[0:800] else \"\" end)}\n  )'"
      }
    },
    {
      "id": "get-task-reviews",
      "type": "shell",
      "purpose": "Read task-review.md files for referenced tasks",
      "params": {
        "stdin": "${get-commits-enriched.stdout}",
        "command": "# Extract unique task numbers\ntask_nums=$(jq -r '[.[].task_number | select(. != null)] | unique | .[]')\n\necho '{'\nfirst=true\nfor num in $task_nums; do\n  review_file=\".taskmaster/tasks/task_$num/task-review.md\"\n  if [ -f \"$review_file\" ]; then\n    content=$(cat \"$review_file\")\n    if [ -n \"$content\" ]; then\n      if [ \"$first\" = true ]; then first=false; else echo ','; fi\n      printf '\"%s\": %s' \"$num\" \"$(printf '%s' \"$content\" | jq -Rs .)\"\n    fi\n  fi\ndone\necho '}'"
      }
    },
    {
      "id": "analyze-commits",
      "type": "llm",
      "purpose": "Classify each commit as user-facing or internal",
      "batch": {
        "items": "${get-commits-enriched.stdout}",
        "parallel": true,
        "max_concurrent": 50,
        "error_handling": "continue"
      },
      "params": {
        "prompt": "Analyze this change for a user-facing changelog entry.\n\n## Context\nIs PR merge: ${item.is_merge}\nCommit message: ${item.commit_message}\nFiles changed: ${item.files_changed}\nPR Number: ${item.pr_number}\nPR Title: ${item.pr_title}\nPR Summary: ${item.pr_summary}\nPR Link: ${item.pr_link}\n\n## Instructions\nIf this is a PR merge (is_merge=true), use the PR Title and PR Summary to understand what changed.\nIf this is a direct commit, use the commit message.\n\n## CRITICAL: No guessing or inferring\n- ONLY use information explicitly provided in the commit/PR\n- If the commit message is minimal (e.g., \"fix bug\"), keep the changelog entry minimal\n- Do NOT invent details, add context, or guess what the change might do\n- Do NOT embellish with phrases like \"for better performance\" unless explicitly stated\n- If unclear whether user-facing, default to SKIP\n- ALWAYS specify WHAT component/node/feature changed (e.g., \"Added timeout parameter to shell node\" not just \"Added timeout parameter\")\n\nSTRICT RULES - Output \"SKIP: <original commit message>\" unless this DIRECTLY affects end users:\n\n\u2705 INCLUDE (user-facing):\n- New CLI commands or features users can use\n- New workflow capabilities\n- Bug fixes that users would have encountered\n- Breaking changes users need to know about\n- Performance improvements users would notice\n\n\u274c SKIP (not user-facing):\n- Internal refactoring or code cleanup\n- Developer tooling improvements\n- Documentation updates\n- Test improvements\n- CI/CD changes\n- Internal implementation details\n- Dependency updates\n- Task/planning files (e.g., \"add task for X\")\n- Files in internal paths: .claude/, .taskmaster/, .github/, tests/\n\n## Output Format\nIf INCLUDE and has PR link: Write entry ending with [#N](link)\n  Example: \"Added batch processing with parallel execution [#17](https://github.com/owner/repo/pull/17)\"\n\nIf INCLUDE but no PR: Write entry without link\n  Example: \"Fixed crash when running with empty input\"\n\nIf SKIP: Output \"SKIP: \" followed by the ORIGINAL commit message (not a summary)\n  Example: \"SKIP: docs: update README\" (keep the exact commit message)\n  Example: \"SKIP: chore: update dependencies\"\n  Example: \"SKIP: test: add unit tests for parser\"\n  Example: \"SKIP: add task for feature X\" (planning, not implementation)\n\nOutput ONLY the changelog line or SKIP line. Nothing else."
      }
    },
    {
      "id": "filter-and-format",
      "type": "shell",
      "purpose": "Separate user-facing entries from skipped internal changes",
      "params": {
        "stdin": "${analyze-commits.results}",
        "command": "jq '\n  # Add index to each item, filter nulls\n  [to_entries[] | select(.value.response != null) | {index: .key, response: .value.response}] |\n  \n  # Separate included and skipped\n  [.[] | select(.response | type == \"string\") | select(.response | startswith(\"SKIP\") | not) | select(.response != \"\")] as $included |\n  [.[] | select(.response | type == \"string\") | select(.response | startswith(\"SKIP\")) | .response | sub(\"^SKIP: \"; \"\")] as $skipped |\n  \n  {\n    included: $included,\n    skipped: $skipped\n  }\n'"
      }
    },
    {
      "id": "prepare-context",
      "type": "shell",
      "purpose": "Join draft entries with original commit context for refinement",
      "params": {
        "stdin": {
          "filter": "${filter-and-format.stdout}",
          "commits": "${get-commits-enriched.stdout}"
        },
        "command": "jq '. as $root | .filter.included | map({draft: .response, index: .index, context: ($root.commits[.index] | {commit_message, task_number, files_changed: ((.files_changed // \"\") | split(\", \") | if length > 5 then (.[0:5] | join(\", \")) + \" ... and \\(length - 5) more files\" else . | join(\", \") end), pr_title, pr_body, pr_link, pr_number})})'"
      }
    },
    {
      "id": "compute-bump-type",
      "type": "shell",
      "purpose": "Determine semver bump type (major/minor/patch)",
      "params": {
        "stdin": "${prepare-context.stdout}",
        "command": "jq -r 'map(.draft) | (map(select(startswith(\"Added\"))) | length) as $features | (map(select(startswith(\"Fixed\"))) | length) as $fixes | (map(select(startswith(\"Improved\"))) | length) as $improvements | (map(select(startswith(\"Removed\") or startswith(\"Changed\"))) | length) as $breaking | if $breaking > 0 then \"major\" elif $features > 0 then \"minor\" else \"patch\" end'"
      }
    },
    {
      "id": "compute-next-version",
      "type": "shell",
      "purpose": "Calculate next version number",
      "params": {
        "command": "current=$(echo '${resolve-tag.stdout}' | sed 's/^v//')\nbump=$(echo '${compute-bump-type.stdout}' | tr -d '\\n')\nmajor=$(echo $current | cut -d. -f1)\nminor=$(echo $current | cut -d. -f2)\npatch=$(echo $current | cut -d. -f3)\ncase $bump in\n  major) printf 'v%d.0.0' $((major + 1)) ;;\n  minor) printf 'v%d.%d.0' $major $((minor + 1)) ;;\n  patch) printf 'v%d.%d.%d' $major $minor $((patch + 1)) ;;\nesac"
      }
    },
    {
      "id": "get-dates",
      "type": "shell",
      "purpose": "Get current date for changelog headers",
      "params": {
        "command": "printf '{\"iso\": \"%s\", \"month_year\": \"%s\"}' \"$(date +%Y-%m-%d)\" \"$(date +\"%B %Y\")\""
      }
    },
    {
      "id": "format-both",
      "type": "llm",
      "purpose": "Refine and format changelog for markdown and Mintlify in parallel",
      "batch": {
        "items": [
          {
            "format": "markdown",
            "prompt": "Refine and format these changelog entries as a markdown section for CHANGELOG.md.\n\n## Input\nVersion: ${compute-next-version.stdout}\nDate: ${get-dates.stdout.iso}\n\n## Draft Entries with Context\nEach entry has a `draft` field and a `context.pr_link` field with the full GitHub URL.\n${prepare-context.stdout}\n\n## Task Reviews (for accuracy)\n${get-task-reviews.stdout}\n\n## Documentation Changes (for parameter accuracy)\n${get-docs-diff.stdout}\n\n## Refinement Tasks\n1. Merge duplicates \u2192 combine PR links\n2. Standardize verbs: Allow\u2192Added, Enable\u2192Added, Update\u2192Changed/Improved\n3. Sort by: Removed > Changed > Added > Fixed > Improved\n4. Use docs diff for accurate parameter names\n5. Use task reviews for accurate feature descriptions\n\n## Output Format\n## v1.0.0 (2026-01-04)\n\n- Removed X [#10](https://github.com/owner/repo/pull/10)\n- Changed Y [#11](https://github.com/owner/repo/pull/11)\n- Added Z [#12](https://github.com/owner/repo/pull/12), [#13](https://github.com/owner/repo/pull/13)\n- Fixed W [#14](https://github.com/owner/repo/pull/14)\n\n## Rules\n- Use version and date exactly as provided\n- Each entry as bullet with `- `\n- CRITICAL: Use the FULL pr_link URL from context, not just the PR number\n- Format: [#N](full_url) where full_url is from context.pr_link\n- Combine PR links when merging duplicates\n- Start with ## - no code fences\n- Output ONLY the markdown section"
          },
          {
            "format": "mintlify",
            "prompt": "Generate a Mintlify changelog <Update> component.\n\n## Input\nVersion: ${compute-next-version.stdout}\nMonth/Year: ${get-dates.stdout.month_year}\nBump Type: ${compute-bump-type.stdout}\n\n## Draft Entries\n${prepare-context.stdout}\n\n## Task Reviews\n${get-task-reviews.stdout}\n\n## Documentation Changes\n${get-docs-diff.stdout}\n\n## Required Format\nYou MUST output exactly this structure (with your content):\n\n<Update label=\"MONTH YEAR\" description=\"VERSION\" tags={[\"New releases\", \"Bug fixes\"]}>\n  ## Theme Title\n\n  Brief description.\n\n  **Highlights**\n  - Feature one\n  - Feature two\n\n  ## Another Theme\n\n  Description.\n\n  **Highlights**\n  - Feature three\n</Update>\n\n## Tasks\n1. Group entries into 2-4 themes\n2. Merge duplicates\n3. Standardize verbs (Allow\u2192Added, Enable\u2192Added)\n4. No PR links (user-facing changelog)\n5. Add <Accordion title=\"Breaking changes\"> if bump type is major\n\n## CRITICAL\n- Output ONLY the <Update>...</Update> component\n- First character must be <\n- Last characters must be </Update>\n- NO JSON, NO code fences, NO explanations"
          }
        ],
        "parallel": true
      },
      "params": {
        "prompt": "${item.prompt}"
      }
    },
    {
      "id": "save-release-context",
      "type": "shell",
      "purpose": "Save full context to version-named file for AI agents and verification",
      "params": {
        "stdin": {
          "changelog": "${format-both.results[0].response}",
          "skipped": "${filter-and-format.stdout.skipped}",
          "task_reviews": "${get-task-reviews.stdout}",
          "docs_diff": "${get-docs-diff.stdout}",
          "draft_entries": "${prepare-context.stdout}"
        },
        "command": "version='${compute-next-version.stdout}'\ndate='${get-dates.stdout.iso}'\nreleases_dir='${releases_dir}'\n\nmkdir -p \"$releases_dir\"\noutfile=\"$releases_dir/$version-context.md\"\n\n# Capture stdin to temp file (handles large data)\ntmpfile=$(mktemp)\ncat > \"$tmpfile\"\n\n# Build file section by section\nprintf '%s\\n' \"# $version Release Context\" > \"$outfile\"\nprintf '\\n%s\\n' \"Generated: $date\" >> \"$outfile\"\nprintf '%s\\n' \"This file contains implementation context for AI agents and release verification.\" >> \"$outfile\"\nprintf '\\n%s\\n\\n' \"---\" >> \"$outfile\"\n\n# Changelog section\nprintf '%s\\n\\n' \"## Changelog\" >> \"$outfile\"\njq -r '.changelog' \"$tmpfile\" >> \"$outfile\"\nprintf '\\n%s\\n\\n' \"---\" >> \"$outfile\"\n\n# Skipped changes section\nprintf '%s\\n\\n' \"## Skipped Changes (Verification)\" >> \"$outfile\"\nprintf '%s\\n\\n' \"Review these to ensure nothing was incorrectly classified as internal:\" >> \"$outfile\"\njq -r '.skipped[]? // empty | \"- \" + .' \"$tmpfile\" >> \"$outfile\"\nprintf '\\n%s\\n\\n' \"---\" >> \"$outfile\"\n\n# Task reviews section\nprintf '%s\\n\\n' \"## Task Implementation Reviews\" >> \"$outfile\"\njq -r '.task_reviews | to_entries[]? // empty | \"### Task \" + .key + \"\\n\\n\" + .value + \"\\n\"' \"$tmpfile\" >> \"$outfile\"\nprintf '%s\\n\\n' \"---\" >> \"$outfile\"\n\n# Documentation changes section\nprintf '%s\\n\\n' \"## Documentation Changes\" >> \"$outfile\"\njq -r '.docs_diff // \"\"' \"$tmpfile\" >> \"$outfile\"\nprintf '\\n%s\\n\\n' \"---\" >> \"$outfile\"\n\n# Draft entries section\nprintf '%s\\n\\n' \"## Draft Entries with Context\" >> \"$outfile\"\nprintf '%s\\n' '```json' >> \"$outfile\"\njq '.draft_entries' \"$tmpfile\" >> \"$outfile\"\nprintf '%s\\n' '```' >> \"$outfile\"\n\nrm -f \"$tmpfile\"\necho \"Saved context to $outfile\""
      }
    },
    {
      "id": "update-changelog-file",
      "type": "shell",
      "purpose": "Prepend new section to CHANGELOG.md",
      "params": {
        "stdin": "${format-both.results[0].response}",
        "command": "changelog_file='${changelog_file}'\nnew_section=$(cat)\n\nif [ -f \"$changelog_file\" ]; then\n  if head -1 \"$changelog_file\" | grep -q '^# '; then\n    { head -1 \"$changelog_file\"; echo \"\"; printf '%s\\n' \"$new_section\"; tail -n +2 \"$changelog_file\"; } > /tmp/changelog_new\n  else\n    { printf '%s\\n' \"$new_section\"; cat \"$changelog_file\"; } > /tmp/changelog_new\n  fi\n  mv /tmp/changelog_new \"$changelog_file\"\nelse\n  { echo \"# Changelog\"; echo \"\"; printf '%s\\n' \"$new_section\"; } > \"$changelog_file\"\nfi\n\necho \"Updated $changelog_file\""
      }
    },
    {
      "id": "update-mintlify-file",
      "type": "shell",
      "purpose": "Prepend Update component to changelog.mdx",
      "params": {
        "stdin": "${format-both.results[1].response}",
        "command": "mintlify_file='${mintlify_file}'\nnew_section=$(cat)\n\n# Skip if no mintlify file specified\nif [ -z \"$mintlify_file\" ]; then\n  echo \"Skipped mintlify (no file specified)\"\n  exit 0\nfi\n\nif [ -f \"$mintlify_file\" ]; then\n  # Find the line after the frontmatter (after second ---)\n  frontmatter_end=$(awk '/^---$/{c++; if(c==2){print NR; exit}}' \"$mintlify_file\")\n  if [ -n \"$frontmatter_end\" ]; then\n    { head -n \"$frontmatter_end\" \"$mintlify_file\"; echo \"\"; printf '%s\\n' \"$new_section\"; tail -n +$((frontmatter_end + 1)) \"$mintlify_file\"; } > /tmp/mintlify_new\n  else\n    { printf '%s\\n' \"$new_section\"; echo \"\"; cat \"$mintlify_file\"; } > /tmp/mintlify_new\n  fi\n  mv /tmp/mintlify_new \"$mintlify_file\"\nelse\n  # Create new file with frontmatter\n  { echo '---'; echo 'title: \"Changelog\"'; echo 'description: \"Product updates and announcements\"'; echo 'icon: \"clock\"'; echo 'rss: true'; echo '---'; echo \"\"; printf '%s\\n' \"$new_section\"; } > \"$mintlify_file\"\nfi\n\necho \"Updated $mintlify_file\""
      }
    },
    {
      "id": "create-summary",
      "type": "shell",
      "purpose": "Create release summary for CLI output",
      "params": {
        "stdin": {
          "entries": "${prepare-context.stdout}",
          "skipped": "${filter-and-format.stdout.skipped}",
          "task_reviews": "${get-task-reviews.stdout}"
        },
        "command": "version=$(printf '%s' '${compute-next-version.stdout}' | tr -d '\\n')\nbump=$(printf '%s' '${compute-bump-type.stdout}' | tr -d '\\n')\ndate=$(printf '%s' '${get-dates.stdout.iso}' | tr -d '\\n')\nchangelog='${changelog_file}'\nmintlify='${mintlify_file}'\nreleases_dir='${releases_dir}'\n\n# Capture stdin to temp file\ntmpfile=$(mktemp)\ncat > \"$tmpfile\"\n\n# Count items\nuser_facing=$(jq '.entries | length' \"$tmpfile\")\nskipped=$(jq '.skipped | length' \"$tmpfile\")\ntask_count=$(jq '.task_reviews | keys | length' \"$tmpfile\")\nrm -f \"$tmpfile\"\n\nprintf '## Release Summary\\n\\n'\nprintf 'Version: %s (%s)\\n' \"$version\" \"$bump\"\nprintf 'Date: %s\\n\\n' \"$date\"\nprintf '%s\\n' \"$changelog\"\nprintf '  %d user-facing entries\\n\\n' \"$user_facing\"\nif [ -n \"$mintlify\" ]; then\n  printf '%s\\n' \"$mintlify\"\n  printf '  Mintlify format (same entries)\\n\\n'\nfi\nprintf '%s/%s-context.md\\n' \"$releases_dir\" \"$version\"\nprintf '  %d skipped changes (for verification)\\n' \"$skipped\"\nprintf '  %d task reviews\\n' \"$task_count\""
      }
    }
  ],
  "edges": [
    {
      "from": "get-latest-tag",
      "to": "resolve-tag"
    },
    {
      "from": "resolve-tag",
      "to": "get-docs-diff"
    },
    {
      "from": "get-docs-diff",
      "to": "get-recent-updates"
    },
    {
      "from": "get-recent-updates",
      "to": "get-commits-enriched"
    },
    {
      "from": "get-commits-enriched",
      "to": "get-task-reviews"
    },
    {
      "from": "get-task-reviews",
      "to": "analyze-commits"
    },
    {
      "from": "analyze-commits",
      "to": "filter-and-format"
    },
    {
      "from": "filter-and-format",
      "to": "prepare-context"
    },
    {
      "from": "compute-bump-type",
      "to": "compute-next-version"
    },
    {
      "from": "compute-next-version",
      "to": "get-dates"
    },
    {
      "from": "save-release-context",
      "to": "update-changelog-file"
    },
    {
      "from": "update-changelog-file",
      "to": "update-mintlify-file"
    },
    {
      "from": "update-mintlify-file",
      "to": "create-summary"
    },
    {
      "from": "prepare-context",
      "to": "compute-bump-type"
    },
    {
      "from": "get-dates",
      "to": "format-both"
    },
    {
      "from": "format-both",
      "to": "save-release-context"
    }
  ],
  "outputs": {
    "summary": {
      "source": "${create-summary.stdout}",
      "description": "Release summary"
    },
    "suggested_version": {
      "source": "${compute-next-version.stdout}",
      "description": "Suggested next version based on changes"
    },
    "markdown_section": {
      "source": "${format-both.results[0].response}",
      "description": "Markdown changelog section"
    },
    "mintlify_section": {
      "source": "${format-both.results[1].response}",
      "description": "Mintlify Update component"
    },
    "context_file": {
      "source": "${save-release-context.stdout}",
      "description": "Path to release context file"
    }
  }
}
