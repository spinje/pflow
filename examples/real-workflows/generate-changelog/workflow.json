{
  "inputs": {
    "since_tag": {
      "type": "string",
      "required": false,
      "default": "",
      "description": "Tag to start from (default: latest tag)"
    },
    "changelog_file": {
      "type": "string",
      "required": false,
      "default": "CHANGELOG.md",
      "description": "Path to markdown changelog file"
    },
    "mintlify_file": {
      "type": "string",
      "required": false,
      "default": "docs/changelog.mdx",
      "description": "Path to Mintlify changelog (pass empty string to skip)"
    }
  },
  "nodes": [
    {
      "id": "get-latest-tag",
      "type": "git-get-latest-tag",
      "purpose": "Get latest git tag as baseline"
    },
    {
      "id": "resolve-tag",
      "type": "shell",
      "purpose": "Use provided tag or default to latest",
      "params": {
        "command": "provided='${since_tag}'\nlatest='${get-latest-tag.latest_tag.name}'\nif [ -n \"$provided\" ]; then echo \"$provided\"; else echo \"$latest\"; fi | tr -d '\\n'"
      }
    },
    {
      "id": "get-commits-enriched",
      "type": "shell",
      "purpose": "Fetch commits since tag with PR metadata",
      "params": {
        "command": "tag='${resolve-tag.stdout}'\nrepo=$(gh repo view --json nameWithOwner -q '.nameWithOwner')\ncommits=$(git log --first-parent \"$tag\"..HEAD --format='{\"hash\":\"%H\",\"subject\":\"%s\"}' | jq -s '.')\nprs=$(gh pr list --state merged --limit 200 --json number,title,body 2>/dev/null || echo '[]')\necho \"$commits\" | jq --argjson prs \"$prs\" --arg repo \"$repo\" 'map(. + {pr_number: null, pr_title: \"\", pr_body: \"\", pr_link: \"\", is_merge: false} | if .subject | test(\"^Merge pull request #[0-9]+\") then (.subject | capture(\"#(?<num>[0-9]+)\").num | tonumber) as $prnum | ($prs | map(select(.number == $prnum)) | first // {}) as $pr | . + {pr_number: $prnum, pr_title: ($pr.title // \"\"), pr_body: ($pr.body // \"\"), pr_link: \"https://github.com/\\($repo)/pull/\\($prnum)\", is_merge: true} elif .subject | test(\"\\\\(#[0-9]+\\\\)\") then (.subject | capture(\"\\\\(#(?<num>[0-9]+)\\\\)\").num | tonumber) as $prnum | . + {pr_number: $prnum, pr_link: \"https://github.com/\\($repo)/pull/\\($prnum)\"} else . end)'"
      }
    },
    {
      "id": "analyze",
      "type": "llm",
      "purpose": "Classify each commit as user-facing or internal",
      "batch": {
        "items": "${get-commits-enriched.stdout}",
        "parallel": true,
        "max_concurrent": 10,
        "error_handling": "continue"
      },
      "params": {
        "prompt": "Analyze this change for a user-facing changelog entry.\n\n## Context\nIs PR merge: ${item.is_merge}\nCommit subject: ${item.subject}\nPR Number: ${item.pr_number}\nPR Title: ${item.pr_title}\nPR Body: ${item.pr_body}\nPR Link: ${item.pr_link}\n\n## Instructions\nIf this is a PR merge (is_merge=true), use the PR Title and PR Body to understand what changed.\nIf this is a direct commit, use the commit subject.\n\n## CRITICAL: No guessing or inferring\n- ONLY use information explicitly provided in the commit/PR\n- If the commit message is minimal (e.g., \"fix bug\"), keep the changelog entry minimal\n- Do NOT invent details, add context, or guess what the change might do\n- Do NOT embellish with phrases like \"for better performance\" unless explicitly stated\n- If unclear whether user-facing, default to SKIP\n- ALWAYS specify WHAT component/node/feature changed (e.g., \"Added timeout parameter to shell node\" not just \"Added timeout parameter\")\n\nSTRICT RULES - Output \"SKIP: <original subject>\" unless this DIRECTLY affects end users:\n\n\u2705 INCLUDE (user-facing):\n- New CLI commands or features users can use\n- New workflow capabilities\n- Bug fixes that users would have encountered\n- Breaking changes users need to know about\n- Performance improvements users would notice\n\n\u274c SKIP (not user-facing):\n- Internal refactoring or code cleanup\n- Developer tooling improvements\n- Documentation updates\n- Test improvements\n- CI/CD changes\n- Internal implementation details\n- Dependency updates\n\n## Output Format\nIf INCLUDE and has PR link: Write entry ending with [#N](link)\n  Example: \"Added batch processing with parallel execution [#17](https://github.com/owner/repo/pull/17)\"\n\nIf INCLUDE but no PR: Write entry without link\n  Example: \"Fixed crash when running with empty input\"\n\nIf SKIP: Output \"SKIP: \" followed by the ORIGINAL commit subject (not a summary)\n  Example: \"SKIP: docs: update README\" (keep the exact commit message)\n  Example: \"SKIP: chore: update dependencies\"\n  Example: \"SKIP: test: add unit tests for parser\"\n\nOutput ONLY the changelog line or SKIP line. Nothing else."
      }
    },
    {
      "id": "filter-and-format",
      "type": "shell",
      "purpose": "Separate user-facing entries from skipped internal changes",
      "params": {
        "stdin": "${analyze.results}",
        "command": "jq '\n  # Add index to each item, filter nulls\n  [to_entries[] | select(.value.response != null) | {index: .key, response: .value.response}] |\n  \n  # Separate included and skipped\n  [.[] | select(.response | type == \"string\") | select(.response | startswith(\"SKIP\") | not) | select(.response != \"\")] as $included |\n  [.[] | select(.response | type == \"string\") | select(.response | startswith(\"SKIP\")) | .response | sub(\"^SKIP: \"; \"\")] as $skipped |\n  \n  {\n    included: $included,\n    skipped: $skipped\n  }\n'"
      }
    },
    {
      "id": "prepare-context",
      "type": "shell",
      "purpose": "Join draft entries with original commit context for refinement",
      "params": {
        "stdin": {
          "filter": "${filter-and-format.stdout}",
          "commits": "${get-commits-enriched.stdout}"
        },
        "command": "jq '. as $root | .filter.included | map({draft: .response, index: .index, context: ($root.commits[.index] | {subject, pr_title, pr_body, pr_link, pr_number})})'"
      }
    },
    {
      "id": "refine-entries",
      "type": "llm",
      "purpose": "Polish entries: merge duplicates, standardize format, sort by priority",
      "params": {
        "prompt": "You are refining changelog entries for end users.\n\n## Draft Entries\n${prepare-context.stdout}\n\n## Format Rules\nEvery entry: `<Verb> <what> [in <component>] [#N](url)`\n\nVerb priority (this IS the sort order):\n1. Removed - features/APIs removed (breaking)\n2. Changed - behavior changes (breaking if incompatible)\n3. Added - new capabilities\n4. Fixed - bug fixes\n5. Improved - enhancements\n\n## Examples\n\u2705 \"Added batch processing to workflow execution [#17](url)\"\n\u2705 \"Fixed shell node crash on empty stdin [#26](url)\"\n\u274c \"Updated the thing\" (too vague)\n\u274c \"Bug fix\" (what bug? where?)\n\n## Tasks\n1. Merge duplicates \u2192 combine PR links: [#10](url), [#12](url)\n2. Standardize verbs (Allow X \u2192 Added X)\n3. Add component specificity from context\n4. Keep each entry to ONE line\n5. Use user-facing language, not internal jargon\n6. Sort by verb priority, then alphabetically\n\n## Constraints\n- NEVER invent details not in context\n- NEVER add entries, only refine\n- Minimal context \u2192 minimal entry\n\n## Output\nJSON array only:\n[\"Removed X [#10](url)\", \"Added Y [#11](url)\", ...]"
      }
    },
    {
      "id": "compute-bump-type",
      "type": "shell",
      "purpose": "Determine semver bump type (major/minor/patch)",
      "params": {
        "stdin": "${refine-entries.response}",
        "command": "jq -r '\n  (map(select(startswith(\"Added\"))) | length) as $features |\n  (map(select(startswith(\"Fixed\"))) | length) as $fixes |\n  (map(select(startswith(\"Improved\"))) | length) as $improvements |\n  (map(select(startswith(\"Removed\") or startswith(\"Changed\"))) | length) as $breaking |\n  \n  if $breaking > 0 then \"major\"\n  elif $features > 0 then \"minor\"\n  else \"patch\" end\n'"
      }
    },
    {
      "id": "compute-next-version",
      "type": "shell",
      "purpose": "Calculate next version number",
      "params": {
        "command": "current=$(echo '${resolve-tag.stdout}' | sed 's/^v//')\nbump=$(echo '${compute-bump-type.stdout}' | tr -d '\\n')\nmajor=$(echo $current | cut -d. -f1)\nminor=$(echo $current | cut -d. -f2)\npatch=$(echo $current | cut -d. -f3)\ncase $bump in\n  major) printf 'v%d.0.0' $((major + 1)) ;;\n  minor) printf 'v%d.%d.0' $major $((minor + 1)) ;;\n  patch) printf 'v%d.%d.%d' $major $minor $((patch + 1)) ;;\nesac"
      }
    },
    {
      "id": "get-dates",
      "type": "shell",
      "purpose": "Get current date for changelog headers",
      "params": {
        "command": "printf '{\"iso\": \"%s\", \"month_year\": \"%s\"}' \"$(date +%Y-%m-%d)\" \"$(date +\"%B %Y\")\""
      }
    },
    {
      "id": "format-both",
      "type": "llm",
      "purpose": "Generate markdown and Mintlify formats in parallel",
      "batch": {
        "items": [
          {
            "format": "markdown",
            "prompt": "Format these changelog entries as a markdown section.\n\n## Input\nVersion: ${compute-next-version.stdout}\nDate: ${get-dates.stdout.iso}\nEntries: ${refine-entries.response}\nSkipped: ${filter-and-format.stdout.skipped}\n\n## Output Format\n## v1.0.0 (2026-01-01)\n\n- Entry one [#N](url)\n- Entry two\n\n<details>\n<summary>N internal changes not included</summary>\n\n- skipped item\n</details>\n\n## Rules\n- Use version and date exactly as provided\n- Each entry as bullet point with `- ` prefix\n- Preserve PR links exactly\n- Add <details> section only if skipped array is non-empty\n- Start with ## - no code fences\n- Output ONLY the markdown"
          },
          {
            "format": "mintlify",
            "prompt": "Format these changelog entries as a Mintlify <Update> component.\n\n## Input\nVersion: ${compute-next-version.stdout}\nMonth/Year: ${get-dates.stdout.month_year}\nEntries: ${refine-entries.response}\n\n## Output Format\n<Update label=\"January 2026\" description=\"v1.0.0\" tags={[\"New releases\"]}>\n  ## Feature Group Title\n\n  Brief 1-2 sentence description.\n\n  **Highlights**\n  - Key point one\n  - Key point two\n</Update>\n\n## Rules\n- Use version and month/year exactly as provided\n- Group related entries by theme (2-4 groups)\n- Write 1-2 sentence summary per group\n- Use **Bold headers** for sub-sections\n- Tags: combine from \"New releases\", \"Improvements\", \"Bug fixes\"\n- Start with <Update> - no code fences\n- End with </Update>"
          }
        ],
        "parallel": true
      },
      "params": {
        "prompt": "${item.prompt}"
      }
    },
    {
      "id": "update-changelog-file",
      "type": "shell",
      "purpose": "Prepend new section to CHANGELOG.md",
      "params": {
        "stdin": "${format-both.results[0].response}",
        "command": "changelog_file='${changelog_file}'\nnew_section=$(cat)\n\nif [ -f \"$changelog_file\" ]; then\n  if head -1 \"$changelog_file\" | grep -q '^# '; then\n    { head -1 \"$changelog_file\"; echo \"\"; printf '%s\\n' \"$new_section\"; tail -n +2 \"$changelog_file\"; } > /tmp/changelog_new\n  else\n    { printf '%s\\n' \"$new_section\"; cat \"$changelog_file\"; } > /tmp/changelog_new\n  fi\n  mv /tmp/changelog_new \"$changelog_file\"\nelse\n  { echo \"# Changelog\"; echo \"\"; printf '%s\\n' \"$new_section\"; } > \"$changelog_file\"\nfi\n\necho \"Updated $changelog_file\""
      }
    },
    {
      "id": "update-mintlify-file",
      "type": "shell",
      "purpose": "Prepend Update component to changelog.mdx",
      "params": {
        "stdin": "${format-both.results[1].response}",
        "command": "mintlify_file='${mintlify_file}'\nnew_section=$(cat)\n\n# Skip if no mintlify file specified\nif [ -z \"$mintlify_file\" ]; then\n  echo \"Skipped mintlify (no file specified)\"\n  exit 0\nfi\n\nif [ -f \"$mintlify_file\" ]; then\n  # Find the line after the frontmatter (after second ---)\n  frontmatter_end=$(awk '/^---$/{c++; if(c==2){print NR; exit}}' \"$mintlify_file\")\n  if [ -n \"$frontmatter_end\" ]; then\n    { head -n \"$frontmatter_end\" \"$mintlify_file\"; echo \"\"; printf '%s\\n' \"$new_section\"; tail -n +$((frontmatter_end + 1)) \"$mintlify_file\"; } > /tmp/mintlify_new\n  else\n    { printf '%s\\n' \"$new_section\"; echo \"\"; cat \"$mintlify_file\"; } > /tmp/mintlify_new\n  fi\n  mv /tmp/mintlify_new \"$mintlify_file\"\nelse\n  # Create new file with frontmatter\n  { echo '---'; echo 'title: \"Changelog\"'; echo 'description: \"Product updates and announcements\"'; echo 'icon: \"clock\"'; echo 'rss: true'; echo '---'; echo \"\"; printf '%s\\n' \"$new_section\"; } > \"$mintlify_file\"\nfi\n\necho \"Updated $mintlify_file\""
      }
    }
  ],
  "edges": [
    {
      "from": "get-latest-tag",
      "to": "resolve-tag"
    },
    {
      "from": "resolve-tag",
      "to": "get-commits-enriched"
    },
    {
      "from": "get-commits-enriched",
      "to": "analyze"
    },
    {
      "from": "analyze",
      "to": "filter-and-format"
    },
    {
      "from": "filter-and-format",
      "to": "prepare-context"
    },
    {
      "from": "prepare-context",
      "to": "refine-entries"
    },
    {
      "from": "refine-entries",
      "to": "compute-bump-type"
    },
    {
      "from": "compute-bump-type",
      "to": "compute-next-version"
    },
    {
      "from": "compute-next-version",
      "to": "get-dates"
    },
    {
      "from": "get-dates",
      "to": "format-both"
    },
    {
      "from": "format-both",
      "to": "update-changelog-file"
    },
    {
      "from": "update-changelog-file",
      "to": "update-mintlify-file"
    }
  ],
  "outputs": {
    "suggested_version": {
      "source": "${compute-next-version.stdout}",
      "description": "Suggested next version based on changes"
    },
    "markdown_section": {
      "source": "${format-both.results[0].response}",
      "description": "Markdown changelog section"
    },
    "mintlify_section": {
      "source": "${format-both.results[1].response}",
      "description": "Mintlify Update component"
    },
    "refined_entries": {
      "source": "${refine-entries.response}",
      "description": "Refined and sorted changelog entries"
    },
    "result": {
      "source": "${update-mintlify-file.stdout}",
      "description": "Confirmation of file updates"
    }
  }
}
