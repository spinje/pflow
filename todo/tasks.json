{
  "tasks": [
    {
      "id": 1,
      "title": "Create CLI entry point and basic structure",
      "description": "Set up the main CLI entry point using click framework with basic command structure and flag parsing",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "Create src/pflow/cli.py with click-based CLI framework. Implement basic --key=value flag parsing without sophisticated categorization. Set up command routing structure for 'pflow <workflow>', 'pflow registry', 'pflow inspect', and 'pflow trace' commands. Create package structure: src/pflow/core/, src/pflow/registry/, src/pflow/nodes/, src/pflow/planning/. Implement inspect commands: 'pflow inspect shared-store' (show current shared store state), 'pflow inspect params --node=<node>' (show node parameters), 'pflow inspect template-vars' (show available template variables). Implement 'pflow trace <run_id>' for execution timeline visualization. Reference docs: architecture.md#5.1.3",
      "testStrategy": "Test CLI flag parsing with various input formats. Verify command routing works correctly. Test error handling for invalid commands"
    },
    {
      "id": 2,
      "title": "Implement shared store validation utilities",
      "description": "Create validation functions for the shared store pattern without unnecessary wrapper classes",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "Create src/pflow/core/validation.py with validation functions for the shared store pattern: validate_reserved_keys(shared) to check reserved keys like 'stdin', validate_natural_patterns(shared) to ensure natural key naming conventions, resolve_template_variables(text, shared) to replace $var with shared[var] values. No wrapper class needed - pocketflow already provides the dict pattern, we just need validation utilities. Use plain functions that operate on the shared dict. Part of Phase 1 Core Infrastructure for template-driven workflows. Reference docs: shared-store.md",
      "testStrategy": "Test validation functions with various shared dict scenarios, template resolution accuracy, and error cases"
    },
    {
      "id": 3,
      "title": "Create NodeAwareSharedStore proxy",
      "description": "Implement the proxy pattern for transparent key mapping between nodes with incompatible interfaces",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Create src/pflow/core/proxy.py with NodeAwareSharedStore class. Implement transparent key mapping with zero overhead when no mappings defined. Support input_mappings and output_mappings. Integrate with pocketflow node execution pattern. Reference docs: shared-store.md#2, cli-runtime.md#3",
      "testStrategy": "Test direct access (no mapping), proxy mapping scenarios, and performance overhead measurement"
    },
    {
      "id": 4,
      "title": "Build context-aware CLI parameter resolution",
      "description": "Implement the CLI resolution system that routes flags to shared store or node parameters based on context",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3
      ],
      "priority": "high",
      "details": "Create src/pflow/core/cli_resolver.py. Parse --key=value flags and categorize: data flags \u2192 shared store, behavior flags \u2192 node.set_params(), execution flags \u2192 node config. Handle shell pipe input detection and populate shared['stdin']. Implement JSON IR \u2192 compiled Python code execution pipeline. Reference docs: architecture.md#5.1.1, cli-runtime.md#7",
      "testStrategy": "Test flag categorization logic, stdin detection, and parameter routing accuracy"
    },
    {
      "id": 5,
      "title": "Implement template resolution system",
      "description": "Create the template variable substitution engine for dynamic content access in workflows",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Create src/pflow/core/template_resolver.py. Implement $variable substitution engine that maps to shared store keys. Validate template variables and handle missing variables. Support template resolution at runtime. Detect missing inputs and prompt users for first nodes. Reference docs: architecture.md#5.1.2, shared-store.md",
      "testStrategy": "Test variable substitution, missing variable detection, and error handling"
    },
    {
      "id": 6,
      "title": "Create registry structure and node discovery",
      "description": "Build the file-based node registry system for simple node discovery and metadata storage",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create src/pflow/registry/ structure. Implement file-based node discovery scanning Python modules for pocketflow.Node subclasses. Build metadata extraction from docstrings. Create basic indexing for fast lookups. No versioning in MVP. Support \u226550 developer-focused nodes efficiently. Reference docs: registry.md",
      "testStrategy": "Test node discovery, metadata extraction accuracy, and registry performance"
    },
    {
      "id": 7,
      "title": "Design complete JSON IR system",
      "description": "Create the JSON IR schema with full support for nodes, edges, mappings, and template variables",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "high",
      "details": "Create src/pflow/core/ir_schema.py. Define complete schema with proxy mapping support, node specifications with simple sequencing, edge definitions, template variable metadata. Include provenance tracking and validation rules. Reference docs: architecture.md#5.2.2, planner.md#10.1",
      "testStrategy": "Test schema validation, IR generation, and compatibility with execution engine"
    },
    {
      "id": 8,
      "title": "Build enhanced metadata extraction system",
      "description": "Implement comprehensive docstring parsing for node interface metadata and parameter classification",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Create src/pflow/registry/metadata_extractor.py. Use docstring_parser + custom regex to extract Interface sections. Parse inputs, outputs, data_params, behavior_params for each node. Support both simple and structured Interface formats. Classify parameters as data_params (\u2192 shared store) vs behavior_params (\u2192 node.set_params()). Track template variables produced/consumed by nodes. Generate JSON metadata for each node with source hash computation for staleness detection. Part of Phase 2 Metadata & Registry Systems. Reference docs: planner.md#5.1",
      "testStrategy": "Test extraction from various docstring formats, parameter classification accuracy"
    },
    {
      "id": 9,
      "title": "Create registry CLI commands",
      "description": "Implement CLI commands for registry operations: list, describe, and search nodes",
      "status": "pending",
      "dependencies": [
        1,
        6,
        8
      ],
      "priority": "medium",
      "details": "Create src/pflow/cli/registry.py. Implement 'pflow registry list' showing individual platform nodes, 'pflow registry describe <node>' for detailed info with rich formatting for node-specific parameters. Part of enhanced registry infrastructure for fast lookups by node ID and capabilities. Reference docs: registry.md",
      "testStrategy": "Test CLI output formatting, search functionality, and error handling"
    },
    {
      "id": 10,
      "title": "Implement github-get-issue node",
      "description": "Create the first simple GitHub node for retrieving issue details",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "high",
      "details": "Create src/pflow/nodes/github/github_get_issue.py inheriting from pocketflow.Node. Implement simple single-purpose node that reads issue_number and repo from shared store or params. Use PyGithub or requests for API calls. Natural interface: shared['repo'], shared['issue'], shared['issue_title']. Authentication via environment variables (GITHUB_TOKEN). Error handling for API failures and rate limits. Part of Phase 3 Simple Platform Nodes. Reference docs: simple-nodes.md",
      "testStrategy": "Mock GitHub API responses, test parameter handling and error cases"
    },
    {
      "id": 11,
      "title": "Implement claude-code super node",
      "description": "Create the comprehensive Claude Code node for AI-assisted development with project context",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "high",
      "details": "Create src/pflow/nodes/claude_code.py inheriting from pocketflow.Node. Single powerful node with instruction-based interface for AI-assisted development with full project context and file system access. Complex prompt generation from planner templates with structured instructions. Integration with headless Claude Code CLI for workflow automation. Natural interface: shared['prompt'] \u2192 shared['code_report'] (comprehensive development report). Model selection and parameter handling. Part of two-tier AI approach. Reference docs: core-node-packages/claude-nodes.md",
      "testStrategy": "Mock Claude Code CLI responses, test template processing and output parsing"
    },
    {
      "id": 12,
      "title": "Implement general LLM node",
      "description": "Create the general-purpose LLM node for all text processing tasks",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "high",
      "details": "Create src/pflow/nodes/llm.py inheriting from pocketflow.Node. Simple interface for general text processing. Natural interface: shared['prompt'] \u2192 shared['response']. Support multiple providers (Claude API, OpenAI). Smart exception to prevent prompt node proliferation. Reference docs: core-node-packages/llm-nodes.md, architecture.md#3.4",
      "testStrategy": "Mock LLM API responses, test different providers and parameter configurations"
    },
    {
      "id": 13,
      "title": "Implement git-commit node",
      "description": "Create simple git node for committing changes",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "medium",
      "details": "Create src/pflow/nodes/git/git_commit.py inheriting from pocketflow.Node. Simple node reading shared['message'] and shared['files']. Execute git commands with safety checks and confirmation prompts. Natural interface: shared['changes'] \u2192 shared['commit_hash']. Automatic commit message generation support. Each node focused on single git operation. Reference docs: simple-nodes.md",
      "testStrategy": "Mock git commands, test safety measures and error handling"
    },
    {
      "id": 14,
      "title": "Implement read-file and write-file nodes",
      "description": "Create basic file I/O nodes for reading and writing files",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "medium",
      "details": "Create file nodes in src/pflow/nodes/file/, all inheriting from pocketflow.Node: read_file.py, write_file.py, copy_file.py, move_file.py, and delete_file.py. Simple interfaces: read-file uses shared['file_path'] \u2192 shared['content'], write-file uses shared['content'] + shared['file_path'], copy/move use shared['source_path'] + shared['dest_path'], delete uses shared['file_path']. Include safety checks for all destructive operations. Natural interface pattern for file operations. Reference docs: simple-nodes.md",
      "testStrategy": "Test file operations, permission handling, and safety validations"
    },
    {
      "id": 15,
      "title": "Create additional GitHub nodes",
      "description": "Implement remaining GitHub platform nodes: create-pr, list-prs, add-comment, merge-pr",
      "status": "pending",
      "dependencies": [
        10
      ],
      "priority": "low",
      "details": "Create GitHub nodes in src/pflow/nodes/github/, all inheriting from pocketflow.Node: github-create-pr, github-list-prs, github-add-comment, and github-merge-pr. Each with focused single purpose and natural interfaces: shared['pr'], shared['files'], shared['repo']. github-merge-pr includes safety checks and conflict handling with shared['pr_number'], shared['merge_method']. Reference docs: simple-nodes.md",
      "testStrategy": "Mock API responses for each operation, test error handling"
    },
    {
      "id": 16,
      "title": "Build CI and shell nodes",
      "description": "Create comprehensive set of CI and shell execution nodes",
      "status": "pending",
      "dependencies": [
        2,
        6
      ],
      "priority": "low",
      "details": "Create CI and shell nodes, all inheriting from pocketflow.Node. CI nodes in src/pflow/nodes/ci/: ci-run-tests, ci-get-status, ci-trigger-build, ci-get-logs. Shell nodes in src/pflow/nodes/shell/: shell-exec, shell-pipe, shell-background. CI nodes use natural interface: shared['test_command'] \u2192 shared['test_results'], support multiple CI systems (GitHub Actions, Jenkins, local). Shell nodes use shared['command'] \u2192 shared['output'] with shell-background also writing shared['pid']. Auto-detect test frameworks, handle exit codes, timeout handling, and security considerations. Reference docs: simple-nodes.md",
      "testStrategy": "Mock test framework responses, test command execution and timeout handling"
    },
    {
      "id": 17,
      "title": "Create LLM client abstraction",
      "description": "Build the LLM integration layer for natural language planning",
      "status": "pending",
      "dependencies": [
        12
      ],
      "priority": "high",
      "details": "Create src/pflow/planning/llm_client.py. Support for thinking models (Claude, OpenAI o1). Token usage tracking and optimization. Error handling and retry logic with maximum 4 attempts per planning stage. Model configuration via environment variables (ANTHROPIC_API_KEY, OPENAI_API_KEY). Default to Claude Sonnet with fallback strategies for model failures. Part of Phase 4 Natural Language Planning. Reference docs: planner.md#6.2",
      "testStrategy": "Mock LLM API calls, test retry logic and error handling"
    },
    {
      "id": 18,
      "title": "Build sophisticated planning context",
      "description": "Create the context builder that prepares node metadata for LLM selection",
      "status": "pending",
      "dependencies": [
        8,
        17
      ],
      "priority": "high",
      "details": "Create src/pflow/planning/context_builder.py. Load available node metadata with parameter classification. Generate compact, LLM-optimized descriptions. Include template variable mapping information and dependency tracking. Build context for prompt and instruction generation. Part of metadata-driven planning approach. Reference docs: planner.md#6.1",
      "testStrategy": "Test context generation, metadata optimization, and LLM readability"
    },
    {
      "id": 19,
      "title": "Implement workflow generation engine",
      "description": "Create the core engine that transforms natural language into template-driven workflows",
      "status": "pending",
      "dependencies": [
        5,
        7,
        18
      ],
      "priority": "high",
      "details": "Create src/pflow/planning/flow_generator.py. Natural language \u2192 template-driven CLI syntax compilation. Template string composition with embedded $variables for all node inputs. Automatic prompt and instruction generation for complex nodes. Parameter value generation (not just inference). Template variable creation and mapping ($code_report, $commit_message, etc.). Context-aware parameter routing (data vs behavior). Missing input detection and user prompting for required parameters. JSON IR \u2192 compiled Python code generation with template resolution. Target \u2264800ms planning latency. Reference docs: planner.md#6.1",
      "testStrategy": "Test workflow generation accuracy, template resolution, and parameter handling"
    },
    {
      "id": 20,
      "title": "Build workflow storage and approval system",
      "description": "Implement user verification and workflow persistence",
      "status": "pending",
      "dependencies": [
        19
      ],
      "priority": "medium",
      "details": "Create src/pflow/planning/approval.py and src/pflow/core/workflow_storage.py. Show generated CLI workflow for approval with clear presentation of individual node syntax. Allow parameter modifications before execution. Save approved workflows with meaningful names to ~/.pflow/workflows/. Implement pattern recognition for intelligent reuse of existing workflow definitions. Parameter extraction for similar requests to enable 'Plan Once, Run Forever' optimization. Target \u226590% user approval rate. Reference docs: planner.md#11",
      "testStrategy": "Test approval flow, workflow saving/loading, and modification handling"
    },
    {
      "id": 21,
      "title": "Create IR compiler and runtime coordinator",
      "description": "Build the compiler that converts JSON IR to pocketflow.Flow objects with template resolution",
      "status": "pending",
      "dependencies": [
        3,
        4,
        5
      ],
      "priority": "high",
      "details": "Create src/pflow/runtime/compiler.py to convert JSON IR to executable code using pocketflow: compile_ir_to_flow(ir_json) to generate pocketflow.Flow from IR, setup_node_proxies(ir_json, shared) to configure NodeAwareSharedStore if needed, execute_with_tracing(flow, shared) to wrap flow.run() with logging and debugging. DO NOT reimplement execution - pocketflow.Flow already provides orchestration, action-based routing, and lifecycle management. Focus only on IR compilation, template resolution, and pflow-specific runtime features. Reference docs: architecture.md#5.4, runtime.md",
      "testStrategy": "End-to-end workflow execution tests with various node combinations"
    },
    {
      "id": 22,
      "title": "Implement validation framework",
      "description": "Create comprehensive validation for IR, interfaces, and workflow compatibility",
      "status": "pending",
      "dependencies": [
        7,
        21
      ],
      "priority": "high",
      "details": "Create src/pflow/core/validation.py. JSON schema validation for IR. Node interface compatibility checking. Template variable validation. Execution configuration validation. Clear error reporting. Reference docs: planner.md#8, architecture.md#10.3",
      "testStrategy": "Test validation rules, error messages, and edge cases"
    },
    {
      "id": 23,
      "title": "Build caching system",
      "description": "Implement node-level caching for flow_safe nodes",
      "status": "pending",
      "dependencies": [
        21
      ],
      "priority": "medium",
      "details": "Create src/pflow/runtime/cache.py. Cache key computation: node_hash \u2295 params \u2295 input_sha256. Only cache @flow_safe nodes. Local filesystem storage ~/.pflow/cache/. Cache validation and expiration. Reference docs: runtime.md#caching-strategy, architecture.md#9.1",
      "testStrategy": "Test cache hits/misses, key computation, and storage operations"
    },
    {
      "id": 24,
      "title": "Create comprehensive test suite",
      "description": "Build unit and integration tests for all components",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        21,
        22
      ],
      "priority": "high",
      "details": "Create tests/ structure mirroring src/. Unit tests for each component (shared store, CLI flag resolution, node registry, metadata extraction, interface compatibility). Integration tests for end-to-end workflows. Performance benchmark suite in tests/benchmarks/ measuring planning latency (\u2264800ms target), execution speed (\u22642s overhead target), token usage optimization. Error recovery test suite in tests/error_recovery/ for invalid input handling, external service failures, partial execution scenarios. Mock external services. Test natural language \u2192 workflow generation with \u226595% success rate target.",
      "testStrategy": "Achieve >90% code coverage, test all critical paths and error scenarios"
    },
    {
      "id": 25,
      "title": "Polish CLI experience and documentation",
      "description": "Enhance user experience with better error messages, help text, and initial documentation",
      "status": "pending",
      "dependencies": [
        24
      ],
      "priority": "low",
      "details": "Improve error messages with actionable suggestions and clear next steps. Add comprehensive --help for all commands. Create initial README with quickstart guide showing primary workflow example (GitHub issue resolution). Add execution tracing with clear step-by-step output. Support developer workflow scenarios including slash command comparison (10x efficiency gain target). Reference docs: architecture.md#11.3",
      "testStrategy": "User acceptance testing, documentation review, error message clarity"
    },
    {
      "id": 26,
      "title": "Implement interface compatibility system",
      "description": "Create the compatibility analysis for shared store key matching and type validation between nodes",
      "status": "pending",
      "dependencies": [
        2,
        3,
        8
      ],
      "priority": "medium",
      "details": "Create src/pflow/core/compatibility.py. Implement shared store key matching between nodes, type validation for interface connections, and proxy mapping generation for mismatches. Pre-execution workflow validation, parameter type checking, and action availability verification. This is distinct from the general validation framework and focuses specifically on node interface compatibility. Reference docs: architecture.md#10.3",
      "testStrategy": "Test interface matching scenarios, type validation edge cases, and proxy mapping generation"
    },
    {
      "id": 27,
      "title": "Build success metrics instrumentation",
      "description": "Implement comprehensive metrics tracking for planning success, execution reliability, and performance",
      "status": "pending",
      "dependencies": [
        19,
        21
      ],
      "priority": "medium",
      "details": "Create src/pflow/core/metrics.py. Track planning success rate (\u226595% target), execution reliability (\u226598% target), planning latency (\u2264800ms target), execution speed overhead (\u22642s target), and workflow efficiency gain (10x improvement target). Implement timing instrumentation, success/failure tracking, token usage monitoring, and metrics aggregation. Export metrics for monitoring and analysis. Reference docs: architecture.md#11",
      "testStrategy": "Test metrics collection accuracy, performance overhead, and aggregation logic"
    },
    {
      "id": 28,
      "title": "Create prompt engineering system",
      "description": "Build the sophisticated prompt templates and engineering system for natural language planning",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "high",
      "details": "Create src/pflow/planning/prompts.py. Design node selection prompts with metadata context, workflow generation prompts using extracted metadata, and error recovery/retry prompts. Implement prompt templates for different planning stages, context injection mechanisms, and prompt optimization for token efficiency. Support template variable generation and instruction composition for complex nodes like claude-code. Reference docs: planner.md#6.1",
      "testStrategy": "Test prompt generation for various scenarios, template composition, and token optimization"
    },
    {
      "id": 29,
      "title": "Implement additional git nodes",
      "description": "Create remaining git platform nodes: push, create-branch, merge, and status",
      "status": "pending",
      "dependencies": [
        13
      ],
      "priority": "low",
      "details": "Create git nodes in src/pflow/nodes/git/, all inheriting from pocketflow.Node: git-push, git-create-branch, git-merge, and git-status. Each node follows simple single-purpose pattern: git-push reads shared['branch'] and executes push, git-create-branch reads shared['branch_name'] and creates branch, git-merge reads shared['source_branch'] and shared['target_branch'], git-status writes shared['git_status']. Include safety checks and confirmation prompts for destructive operations. Reference docs: simple-nodes.md",
      "testStrategy": "Mock git commands for each operation, test safety measures and edge cases"
    }
  ]
}
