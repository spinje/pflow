# Handoff Memo: Task 16.1 - Create Core Context Builder with Basic Formatting

**TO THE IMPLEMENTING AGENT**: Read this entire memo before starting. When done, acknowledge you're ready to begin - DO NOT start implementing immediately.

## ðŸŽ¯ Critical Knowledge Transfer

### The Real Purpose (What the Docs Don't Tell You)

You're not just formatting metadata - you're creating the "dictionary" that enables AI agents to speak the language of workflow composition. Task 16 creates the context that Task 17's planner will use to achieve 95% success rates. Every formatting decision directly impacts whether the planner can discover and connect nodes correctly.

### The Parameter Pattern That Changes Everything

**Key Insight**: ALL shared store inputs automatically work as parameter fallbacks in pflow. This isn't just a design choice - it's THE pattern that eliminates redundancy.

```python
# In EVERY node's prep() method:
file_path = shared.get("file_path") or self.params.get("file_path")
```

**What this means for you**:
- When formatting, only show "exclusive parameters" - params that are NOT also inputs
- If a param appears in both inputs and params lists, filter it out of params
- This dramatically simplifies the LLM's understanding

**Implementation**:
```python
exclusive_params = [p for p in metadata['params'] if p not in metadata['inputs']]
```

### Critical Files and Their Quirks

**Registry Metadata Format** (from Task 5):
```python
{
    "module": "pflow.nodes.file.read_file",
    "class_name": "ReadFileNode",
    "name": "read-file",
    "docstring": "...",  # Full unparsed docstring - NOT "description"!
    "file_path": "/path/to/file.py"
}
```

**Metadata Extractor Output** (from Task 7):
```python
{
    'description': 'Read content from a file',  # First paragraph of docstring
    'inputs': ['file_path', 'encoding'],       # From "Reads:" section
    'outputs': ['content', 'error'],           # From "Writes:" section
    'params': ['file_path', 'encoding'],       # From "Params:" section
    'actions': ['default', 'error']            # From "Actions:" section
}
```

### The Import Pattern You Must Use

```python
from pflow.runtime.compiler import import_node_class
from pflow.registry.metadata_extractor import PflowMetadataExtractor

# For EACH node in registry_metadata:
try:
    node_class = import_node_class(node_type, registry_metadata)  # node_type is the dict key
    metadata = extractor.extract_metadata(node_class)
except ImportError:
    logger.warning(f"Failed to import {node_type}")
    continue  # Skip this node entirely
```

### User Decisions Already Made

From `/Users/andfal/projects/pflow/.taskmaster/tasks/task_16/task-16-context-builder-ambiguities.md`:

1. **Include only production nodes with valid Interface sections** (skip test nodes)
2. **Skip nodes with missing metadata entirely** (don't show incomplete nodes)
3. **Group nodes by category** (File Operations, Git Operations, etc.)
4. **Show only configuration parameters** (the exclusive params pattern)
5. **Log warnings for import failures but skip them**
6. **No size limits but monitor usage** (log if >50 nodes or >10KB)

### The Strategic Vision Impact

From `16-strategic-vision.md`, remember:
- Bad context creates 5x cost multiplier through retries
- You're enabling "tool awareness" - LLM needs to see what's available
- Format must support connection discovery (which outputs feed which inputs)
- This isn't used once - it's used EVERY workflow generation

But DON'T try to solve Task 17's problems. Your job is clean, clear formatting.

### Warnings About Subtle Issues

1. **Function Parameter Name**: The function receives `registry_metadata` as the parameter name, NOT `node_name` or anything else. This was a correction in the handover.

2. **Creating the Directory**: `src/pflow/planning/` doesn't exist yet. You'll need to create it with `__init__.py`.

3. **Import Failures Are Normal**: Many nodes might fail to import during development. Log and skip - don't crash.

4. **Don't Over-Engineer Categories**: Simple pattern matching on node names is fine. Don't build complex categorization logic.

### Expected Output Format

Based on all decisions and patterns:

```markdown
## File Operations

### read-file
Reads content from a file and adds line numbers for display.

**Inputs**: `file_path`, `encoding`
**Outputs**: `content` (success), `error` (failure)
**Parameters**: `max_lines`  # Only exclusive params shown!

### write-file
Writes content to a file.

**Inputs**: `content`, `file_path`
**Outputs**: `written` (success), `error` (failure)
**Parameters**: `append`, `create_dirs`  # Only exclusive params
```

### Documentation You MUST Read

1. **Primary**: `docs/features/planner.md` Section 6.1 - Shows how your output will be used
2. **Example**: `docs/implementation-details/metadata-extraction.md` lines 784-860 - Has PlannerContextBuilder example
3. **Pattern**: `.taskmaster/knowledge/patterns.md` - Search for "Shared Store Inputs as Automatic Parameter Fallbacks"

### What Would Make Me Furious If I Forgot

1. The exclusive parameters pattern - it's THE key insight that reduces redundancy
2. Registry has "docstring" not "description" field
3. You must use `import_node_class()` from runtime.compiler
4. Test nodes exist and should be filtered out (files with "test" in name/path)
5. The format directly impacts 95% success rate target - every choice matters

### Your Testing Priorities

1. Test the exclusive params filtering works correctly
2. Test with real registry data (not mocked) to catch integration issues
3. Test import failures are handled gracefully
4. Test format is clean and readable (have an LLM read it!)

## ðŸš€ Your Starting Point

1. Create `src/pflow/planning/__init__.py` (empty file)
2. Create `src/pflow/planning/context_builder.py`
3. Start with the function signature: `def build_context(registry_metadata: dict[str, dict[str, Any]]) -> str:`
4. Focus on basic formatting first - no categories, just get nodes formatted correctly

Remember: You're building the dictionary that enables workflow intelligence. Make it clear, make it discoverable, make it work.

**IMPORTANT**: Acknowledge you've read this memo and are ready to begin. Do NOT start implementing until you've confirmed understanding.
