# Handoff Memo: Task 7.1 - Implement Core Metadata Extractor

**TO THE IMPLEMENTING AGENT**: Read this entire memo before starting. When done, acknowledge you're ready to begin - DO NOT start implementing immediately.

## üö® The Non-Obvious Truth About This Task

You're building a **runtime introspection tool**, not a registry enhancement. Task 7 takes a node CLASS as input (after dynamic import), NOT registry data. This distinction is critical - you're building a utility that other components call AFTER they've already imported a node class.

## üí£ Critical Discovery: The ACTUAL Docstring Format

**DO NOT TRUST** the theoretical documentation about docstring formats. The actual nodes in the codebase use this exact format:

```python
"""One-line description.

Detailed description paragraph.

Interface:
- Reads: shared["file_path"] (required), shared["encoding"] (optional)
- Writes: shared["content"] on success, shared["error"] on failure
- Params: file_path, encoding (as fallbacks if not in shared)
- Actions: default (success), error (failure)

Security Note: Optional security warnings.
"""
```

**Where to verify this yourself**:
- `/src/pflow/nodes/file/read_file.py` (lines 18-32)
- `/src/pflow/nodes/file/write_file.py` (lines 21-39)

This is a **simple bullet list**, not YAML, not structured format, not anything fancy. Just bullet points with specific prefixes.

## üéØ What Task 5 Already Did (Don't Duplicate!)

Task 5's scanner (`/src/pflow/registry/scanner.py`) already:
- Finds all BaseNode subclasses
- Extracts the raw docstring as a string
- Stores basic metadata (module path, class name, etc.)

**Your job**: Parse that raw docstring to extract structured data. You're the "deep parser" that Task 5 didn't implement.

## ‚ö†Ô∏è Node Inheritance Gotcha

Both of these are valid nodes you must handle:
```python
from pocketflow import BaseNode  # Test nodes often use this
from pocketflow import Node      # Production nodes use this (Node inherits from BaseNode)
```

Check inheritance with:
```python
import pocketflow
def is_node_class(cls):
    try:
        return issubclass(cls, pocketflow.BaseNode)
    except TypeError:
        return False
```

## üîç The Actual Output Format (No Deviations!)

The task specifies this EXACT format:
```python
{
    'description': 'Get GitHub issue',      # First line of docstring
    'inputs': ['issue_number', 'repo'],     # Just the key names from shared["key"]
    'outputs': ['issue'],                   # Just the key names
    'params': ['token'],                    # Parameter names only
    'actions': ['default', 'not_found']     # Action names only
}
```

**Note**: Just extract the KEY NAMES, not the full `shared["key"]` syntax or any descriptions.

## üìç Where to Look for Implementation Reference

### Must-Read Files
- `/src/pflow/nodes/file/read_file.py` - Perfect example of the docstring format
- `/src/pflow/registry/scanner.py` - Shows how Task 5 works (don't duplicate!)
- `/src/pflow/nodes/test_node.py` - BaseNode inheritance example
- `/src/pflow/nodes/test_node_retry.py` - Node inheritance example

### Documentation That Actually Matters
- `/architecture/implementation-details/metadata-extraction.md` - Your specification
- **IGNORE** any theoretical docstring formats in docs - trust the actual code

## üö´ Anti-Patterns from My Analysis

1. **Don't add docstring_parser library** - It's not installed and not needed
2. **Don't parse theoretical formats** - Only parse what's actually in the codebase
3. **Don't try to be too smart** - Simple regex for simple format
4. **Don't modify registry** - You're a standalone utility

## üéÅ Regex Patterns That Will Save You Time

From the handoff memo at `/Users/andfal/projects/pflow/.taskmaster/tasks/task_7/7_handover.md`:

```python
INTERFACE_PATTERN = r'Interface:\s*\n((?:[ \t]*-[^\n]+\n)*)'
SHARED_KEY_PATTERN = r'shared\["([^"]+)"\]'
ACTIONS_PATTERN = r'(\w+)(?:\s*\([^)]+\))?'
```

These have been verified against actual nodes and work correctly.

## üî• Performance Gotcha

Some nodes have LONG docstrings. Don't try to parse the entire docstring with one massive regex. Instead:
1. Extract the Interface section first
2. Parse individual lines within that section
3. This prevents catastrophic backtracking

## üéØ Testing Strategy for Subtask 7.1

For this first subtask, focus on:
1. Node validation (both Node and BaseNode inheritance)
2. Description extraction (first line/paragraph)
3. Basic structure with empty lists for unparsed sections
4. Clear error for non-nodes

**Don't implement Interface parsing yet** - that's subtask 7.2's job.

## üìù Final Critical Insight

The metadata extractor is used by Task 17 (Natural Language Planner) to understand what nodes can do. The planner needs to know:
- What data a node needs (inputs)
- What data it produces (outputs)
- What parameters it accepts
- What actions it can take

This is why accuracy matters - bad metadata means bad workflow generation.

## üîó Key File Locations

- Create: `/src/pflow/registry/metadata_extractor.py`
- Create tests: `/tests/test_registry/test_metadata_extractor.py`
- Reference: `/src/pflow/registry/scanner.py` (Task 5's work)
- Examples: `/src/pflow/nodes/file/*.py` (real docstrings)

---

**Remember**: Read the actual code, not theoretical docs. The bullet-list Interface format is what's real. Good luck!

**IMPORTANT**: Acknowledge you've read this memo and are ready to begin implementation. Do NOT start implementing until you've confirmed you understand these insights.
