# Subtask 8.2 Handoff: The Validation Trap and Click Context Magic

**TO THE IMPLEMENTING AGENT**: Read this entire memo before starting. When done, acknowledge you're ready to begin - DO NOT start implementing immediately.

## üö® The Core Challenge You're Facing

The validation at lines 52-55 in `src/pflow/cli/main.py` is THE blocker:

```python
if workflow:
    raise click.ClickException(
        "cli: Cannot use stdin input when command arguments are provided..."
    )
```

This validation happens INSIDE `get_input_source()` and blocks ALL stdin when command args exist. But here's the trick: **you need to be surgical**. The validation should remain for the old pattern (`echo workflow | pflow some-args`) but NOT for the new pattern (`cat data | pflow --file workflow.json`).

## üéØ What I Built That You'll Use

The shell integration utilities are now at `src/pflow/core/shell_integration.py`:
- `detect_stdin()` - Returns True if stdin is piped
- `read_stdin()` - Returns content or None (handles empty stdin!)
- `determine_stdin_mode(content)` - Returns "workflow" or "data"
- `populate_shared_store(shared, content)` - Sets shared["stdin"]

**Import like this**:
```python
from pflow.core import read_stdin, determine_stdin_mode, populate_shared_store
```

## üí° Critical Insights About the CLI

### 1. The Two Input Patterns
You're enabling TWO different patterns:
- **OLD**: `echo '{"ir_version": "1.0", ...}' | pflow` (stdin as workflow)
- **NEW**: `cat data.txt | pflow --file workflow.json` (stdin as data)

The key insight: When `--file` is provided, stdin CANNOT be workflow. It must be data.

### 2. The Click Context Pattern
Look at how the CLI already uses `ctx.obj`:
- Line 22: `ctx.obj = {"verbose": verbose}`
- Line 84: `if ctx.obj.get("verbose", False):`

You'll store stdin data here temporarily until line 89 where shared storage is created.

### 3. The Execution Flow
1. `get_input_source()` is called early (before shared storage exists)
2. It returns `(workflow_content, source_type)`
3. Later at line 89: `shared_storage: dict[str, Any] = {}`
4. THIS is where you inject stdin data into shared storage

## ‚ö†Ô∏è Edge Cases and Gotchas

### Empty stdin vs No stdin
The utilities handle this, but be aware:
- `read_stdin()` returns None for both no stdin AND empty stdin
- This is intentional - empty stdin should not populate shared["stdin"]

### The Click CliRunner Issue
In tests, CliRunner makes stdin look piped even when empty. The shell integration utilities already handle this, but your tests need to be aware.

### Backward Compatibility is Critical
The pattern `echo workflow | pflow` MUST continue to work. Only modify behavior when `--file` is present.

## üîó Key Files and Lines

**Primary target**: `src/pflow/cli/main.py`
- Lines 38-62: `get_input_source()` function - needs modification
- Lines 52-55: The validation trap - needs conditional logic
- Line 89: Where shared storage is created - injection point
- Line 22: Where ctx.obj is initialized

**Test file**: `tests/test_cli/test_main.py`
- Has existing tests for stdin validation
- You'll need to ADD tests for the new dual-mode behavior
- Don't break existing tests!

**Documentation**:
- `docs/features/shell-pipes.md` - The full specification
- `.taskmaster/tasks/task_8/research/stdin-handling-patterns.md` - Patterns I researched

## üèóÔ∏è Suggested Implementation Approach

1. **Modify get_input_source()** to read stdin BEFORE validation
2. **Make validation conditional**: Only raise if stdin AND no --file
3. **Store stdin in ctx.obj**: Something like `ctx.obj["stdin_data"] = stdin_content`
4. **Inject at line 89**: Check ctx.obj and populate shared["stdin"] if present
5. **Test both patterns**: Old pattern still works, new pattern enables data

## üß™ Test Patterns That Work

From my testing experience:
```python
# Mock stdin in tests
with patch('sys.stdin', io.StringIO("test data")):
    with patch('sys.stdin.isatty', return_value=False):
        # Your test here
```

The existing test file has good examples of testing CLI with stdin.

## üöÄ What Success Looks Like

When you're done:
1. `echo '{"ir_version": "1.0"}' | pflow` - Still works (stdin as workflow)
2. `cat data.txt | pflow --file workflow.json` - Now works (stdin as data)
3. `pflow --file workflow.json` - Works with no stdin
4. All existing tests pass
5. New tests verify dual-mode behavior

## ‚ùå What NOT to Do

1. **Don't break backward compatibility** - Existing patterns must work
2. **Don't read stdin twice** - It's a stream, read once and store
3. **Don't modify shared storage creation** - Just inject after line 89
4. **Don't overthink it** - This is a surgical modification, not a rewrite

## üìù Final Notes

- The shell integration module from 8.1 is tested and working perfectly
- Focus on the CLI integration, not the utilities
- Remember: When `--file` is present, stdin is ALWAYS data, never workflow
- The project context has user decisions about dual-mode behavior

Good luck! This is a tricky bit of surgery on the CLI validation logic, but with the utilities in place and this guidance, you should be able to implement it cleanly.

**REMEMBER**: Acknowledge you've read this and are ready to begin. Do not start implementing until you've understood everything above.
