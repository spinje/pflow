# Subtask 8.5 Handoff: Stdout Output and Signal Handling

**TO THE IMPLEMENTING AGENT**: Read this entire memo before starting. When done, acknowledge you're ready to begin - DO NOT start implementing immediately.

## üö® Critical Context You Need

### The Current State After 8.4
I just added binary and large file stdin handling. This changed how stdin flows through the system:

1. **Three Types of stdin Data Now**:
   - `shared["stdin"]` - text data (backward compatible)
   - `shared["stdin_binary"]` - binary data as bytes
   - `shared["stdin_path"]` - path to temp file for large data

2. **CLI Changes** (`src/pflow/cli/main.py`):
   - Line 55-62: Now checks for enhanced stdin if text reading fails
   - Lines 136-161: Complex injection logic handling all three types
   - Lines 179-191: Temp file cleanup in finally block

### What 8.5 is REALLY About
This subtask combines TWO different features that both relate to shell integration:
1. **Stdout output** from shared store (for pipe chaining)
2. **Signal handling** (SIGINT, SIGPIPE) with proper exit codes

These are bundled together but are actually independent implementations.

## üí£ Landmines and Gotchas

### 1. Output Detection is Tricky
The spec says "check for 'response', 'output', 'result', 'text' in order" but consider:
- What if multiple keys exist?
- What if the value is binary (from `shared["stdin_binary"]`)?
- What if it's a complex object, not a string?
- Should we output ONLY when stdout is piped? (I think yes)

### 2. SIGPIPE is Platform-Specific
```python
# This will FAIL on Windows:
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

# You need:
if hasattr(signal, 'SIGPIPE'):
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
```

### 3. Exit Code Propagation
Currently, the CLI does this (line 161-164):
```python
if result and isinstance(result, str) and result.startswith("error"):
    click.echo("cli: Workflow execution failed - Node returned error action", err=True)
    ctx.exit(1)
```

But this is checking the flow's return value, not a proper exit code. You need to think about:
- How do nodes signal different exit codes?
- Should we use the flow's return value or add a new mechanism?

### 4. BrokenPipeError vs SIGPIPE
These are related but different:
- SIGPIPE: Unix signal when writing to closed pipe
- BrokenPipeError: Python exception when write fails
- You need to handle BOTH

## üéØ Key Code Locations

**Primary files to modify**:
1. `src/pflow/cli/main.py`:
   - Add `--output-key` option (around line 230 where other options are)
   - Add output logic after workflow execution (after line 169)
   - Enhance signal handling (currently only SIGINT at line 25)

2. Consider creating `src/pflow/core/exit_codes.py`:
   - Define ExitCodes enum
   - Centralize exit code constants

**Current signal handling**:
- `handle_sigint()` at line 25-28 in main.py
- Already uses exit code 130 (good!)
- But only handles SIGINT, not SIGPIPE

## üîó Architecture Decisions You'll Face

### 1. Where to Check for Output
After line 169 where "Workflow executed successfully" is printed? Or replace that message when piping?

### 2. Binary Output Handling
If `shared["output"]` contains bytes, what then?
- Write to stdout.buffer?
- Encode to string?
- Skip output?

### 3. Exit Code Source
Three options:
- Use flow return value (current "error" check)
- Add `shared["exit_code"]` convention
- Add new flow.exit_code property

## üìö Essential Documentation

1. **Shell pipes spec**: `architecture/features/shell-pipes.md`
   - Has a section on "Output to stdout"
   - Mentions exit codes and signals

2. **CLI runtime**: `architecture/features/cli-runtime.md`
   - Shows current CLI structure
   - Helpful for understanding where to add features

3. **My handoff from 8.2**: `.taskmaster/tasks/task_8/subtask_8.2/8.2-handover.md`
   - Has insights about CLI patterns and Click usage

## ‚ö° Patterns to Follow

### From Previous Subtasks
1. **Test subprocess behavior** (from 8.2): The dual_mode_stdin tests use real subprocess calls
2. **Backward compatibility** (from 8.4): Don't break existing behavior
3. **Handle all data types** (from 8.4): Text, binary, and file paths

### For Signal Handling
```python
# Standard pattern:
import signal
import os

def handle_sigpipe(signum, frame):
    # Clean exit for broken pipe
    os._exit(0)

# Register handlers early in main()
signal.signal(signal.SIGINT, handle_sigint)
if hasattr(signal, 'SIGPIPE'):
    signal.signal(signal.SIGPIPE, handle_sigpipe)
```

## üß™ Testing Approaches

### For Stdout Output
```python
# Test with CliRunner
result = runner.invoke(main, ['--output-key', 'result', ...])
assert "expected output" in result.output

# Test with subprocess (more realistic)
proc = subprocess.run(['pflow', '--output-key', 'data'],
                     capture_output=True, text=True)
assert proc.stdout == "expected"
```

### For Signal Handling
```python
# This is tricky to test!
# Consider using subprocess and sending actual signals
proc = subprocess.Popen(['pflow', ...])
proc.send_signal(signal.SIGINT)
assert proc.wait() == 130  # Exit code for SIGINT
```

## ‚ö†Ô∏è What I'd Be Worried About

1. **Silent data loss**: Make sure output errors don't silently fail
2. **Encoding issues**: Binary data could cause Unicode errors
3. **Platform differences**: Test on both Unix and Windows if possible
4. **Performance**: Don't accidentally read huge values into memory for output

## üéÅ Quick Wins

1. Start with the ExitCodes enum - it's independent and useful
2. SIGPIPE handling is a one-liner (with platform check)
3. --output-key with a simple default might be enough for MVP

## üìù Final Notes

- The shell integration from 8.1-8.4 is solid, don't break it
- Click has good patterns for adding options, follow existing style
- Remember: stdout output should probably ONLY happen when piped
- Exit codes matter for shell scripting - get them right

This subtask will complete the shell integration story, making pflow a true Unix citizen that can be chained in pipes and scripted reliably.

**REMEMBER**: Acknowledge you've read this and are ready to begin. Do not start implementing until you've understood everything above.
