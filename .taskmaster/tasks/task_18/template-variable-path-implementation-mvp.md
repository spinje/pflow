# Template Variables with Path Support: MVP Implementation Guide

## Executive Summary

This document provides the implementation guide for template variable support in pflow's MVP. Template variables enable the "Plan Once, Run Forever" philosophy by allowing workflows to be parameterized and reused with different values.

**Key MVP Feature**: Template variables support path-based access (e.g., `$issue_data.user.login`), eliminating the need for complex data mappings in most workflows.

## Connection to Planner Output

The template variable system receives its initial parameters from the Natural Language Planner's output:

```python
# User input: "fix github issue 1234 in pflow repo"
# Planner extracts parameters and returns:
planner_output = {
    "workflow_ir": {...},  # Contains template variables like $issue_number
    "parameter_values": {
        "issue_number": "1234",
        "repo": "pflow"
    }
}

# The CLI passes parameter_values as initial_params to the compiler:
flow = compile_ir_to_flow(
    planner_output["workflow_ir"],
    registry,
    initial_params=planner_output["parameter_values"]  # <-- This connection
)
```

**Key Point**: `initial_params` are NOT command-line flags typed by users. They are values extracted from natural language by the planner's ParameterExtractionNode.

## This IS the Runtime Proxy

This template variable implementation **IS** the "runtime proxy" referenced throughout the planner documentation (task 17):

- **Transparently resolves** template variables at runtime
- **Enables "Plan Once, Run Forever"** by preserving templates in saved workflows
- **Acts as a proxy** between workflow definitions (with templates) and runtime values
- **No modification needed** to existing nodes due to the fallback pattern

Without this runtime proxy, workflows would be single-use with hardcoded values, defeating pflow's core value proposition.

## Requirements and Specifications

### Functional Requirements

1. **Template Variable Detection**
   - MUST detect template variables in any string parameter value
   - MUST support `$variable` syntax (standard format - 99% of cases)
   - SHOULD support `${variable}` syntax for disambiguation only (e.g., `${var}suffix` vs `$varsuffix`)
   - MUST support nested path access: `$variable.field.subfield`
   - MUST handle multiple variables in a single string
   - **Note**: The planner generates ONLY `$variable` format

2. **Resolution Sources**
   - MUST resolve from shared store (workflow runtime data)
   - MUST resolve from parameter values extracted by planner
   - MUST prioritize planner-extracted parameters over shared store when same key exists
   - MUST maintain resolution context throughout workflow execution

3. **Path Traversal**
   - MUST traverse nested dictionaries using dot notation
   - MUST handle missing paths gracefully (no exceptions)
   - MUST convert all resolved values to strings
   - MUST preserve original template if path cannot be resolved

4. **Node Transparency**
   - MUST NOT require changes to existing node implementations
   - MUST intercept at the `_run()` method only
   - MUST preserve node atomicity and isolation
   - MUST work with all existing pflow nodes

### Technical Specifications

1. **Template Syntax**
   ```
   variable_pattern = $identifier | ${identifier}
   identifier = word_char+ ( '.' word_char+ )*
   word_char = [a-zA-Z0-9_]

   Standard format: $identifier (generated by planner)
   Disambiguation format: ${identifier} (edge cases only)
   Path access: $node_id.field.subfield
   ```

2. **Resolution Algorithm**
   ```
   1. Parse template string to find all variables
   2. For each variable:
      a. Split by '.' to get path components
      b. Traverse context dict following path
      c. Convert final value to string
      d. Replace template with resolved value
   3. Return modified string
   ```

3. **Priority Order**
   ```
   Resolution Context = {
     ...shared_store,           # Lower priority (runtime data)
     ...planner_parameters      # Higher priority (extracted values)
   }
   ```

4. **Error Handling**
   - Invalid paths: Leave template unchanged (e.g., `$missing.path` remains `$missing.path`)
   - Non-dict traversal: Stop and leave template unchanged
   - Null/None values: Convert to empty string ("")
   - Complex objects: Convert using str() function
   - **Missing variables**: Template remains unchanged for debugging
   - **Resolution failures are not errors**: Nodes using fallback pattern handle missing values gracefully

5. **Type Conversion Rules**
   ```python
   None → ""         # Empty string
   "" → ""          # Empty string stays empty
   0 → "0"          # Zero becomes string "0"
   False → "False"  # Boolean becomes string "False"
   [] → "[]"        # Empty list becomes string "[]"
   {} → "{}"        # Empty dict becomes string "{}"
   ```

### Non-Functional Requirements

1. **Performance**
   - Resolution MUST complete in O(n*m) time where n=template length, m=path depth
   - No caching required for MVP (stateless resolution)

2. **Compatibility**
   - MUST work with Python 3.8+
   - MUST integrate with existing PocketFlow execution model
   - MUST maintain backward compatibility with non-template parameters

3. **Maintainability**
   - Code MUST be isolated in dedicated modules
   - MUST include comprehensive test coverage
   - MUST follow existing pflow code patterns

### Out of Scope for MVP

1. Array indexing: `$items.0.name`
2. Expression evaluation: `$count + 1`
3. Method calls: `$name.upper()`
4. Default values: `$var|default`
5. Type preservation (everything converts to string)
6. Proxy mappings or key renaming
7. Compile-time resolution

## What You're Building

A template variable resolution system that:
1. Detects template variables in node parameters: `$variable` (standard) or `${variable}` (edge cases)
2. Supports path-based access to nested data: `$issue_data.user.login`
3. Resolves variables at runtime from two sources:
   - Planner-extracted parameters (higher priority)
   - Shared store values from node execution (lower priority)
4. Converts all values to strings
5. Works transparently without modifying existing nodes

**Real-World Example**:
```json
// User says: "fix github issue 1234"
// Planner extracts: {"issue_number": "1234"}
// Workflow contains:
{
  "nodes": [
    {"id": "get_issue", "type": "github-get-issue",
     "params": {"issue": "$issue_number"}},
    {"id": "analyze", "type": "claude-code",
     "params": {"prompt": "Fix issue #$get_issue.issue_data.number: $get_issue.issue_data.title"}}
  ]
}

// Runtime resolution:
// - $issue_number → "1234" (from planner parameters)
// - $get_issue.issue_data.number → "1234" (from shared["get_issue"]["issue_data"]["number"])
// - $get_issue.issue_data.title → "Bug in login" (from shared store)
```

## How Nodes Write to Shared Store

Understanding how nodes create the data structure that templates access is crucial:

```python
# When a node with id="github_main" executes:
def post(self, shared, result):
    # Most nodes write their output to shared[node_id]
    shared["github_main"] = {
        "issue_data": {
            "number": 1234,
            "title": "Bug in login",
            "user": {
                "login": "john",
                "email": "john@example.com"
            }
        }
    }

# This creates the natural namespace that templates access:
# $github_main.issue_data.title → "Bug in login"
# $github_main.issue_data.user.login → "john"
```

**Key Pattern**: Node IDs create natural namespaces in the shared store. This is an existing pattern, not a future feature. The template resolver simply traverses this structure using dot notation.

## Template Variable Constraints

**CRITICAL**: Template variables can ONLY be used in node `params` values:
- ✅ `{"params": {"prompt": "Hello $name"}}` - CORRECT
- ❌ `{"id": "$dynamic_id"}` - NOT SUPPORTED
- ❌ `{"type": "$node_type"}` - NOT SUPPORTED
- ❌ `{"edges": [{"from": "$node1", "to": "$node2"}]}` - NOT SUPPORTED

The JSON IR structure (id, type, edges) must be static. Only parameter values can be dynamic.

## Critical PocketFlow Constraints

Understanding these constraints is essential for implementation:

### 1. Parameters Are Immutable During Execution
```python
# Once set_params() is called:
node.set_params({"file": "data.txt"})
# Node accesses params directly - we CANNOT intercept:
file_path = self.params["file"]  # No proxy possible here!
```

### 2. The Only Interception Point
```python
def _run(self, shared):  # <-- We can only intercept here
    # This is where we can modify node.params before execution
```

### 3. Nodes Are Copied Before Execution
```python
# PocketFlow does this internally:
curr = copy.copy(node)  # Fresh copy for each execution
curr.set_params(params)
curr._run(shared)       # Our interception point
```

## The Fallback Pattern Foundation

Every pflow node implements this pattern:
```python
# In EVERY node's prep() method:
value = shared.get("key") or self.params.get("key")
```

This enables template variables in params to work as dynamic values.

### Why This Pattern Enables Template Variables

This fallback pattern is implemented in EVERY pflow node and is the foundation that makes template variables work:

1. **Node attempts to read from shared store first**: `shared.get("key")`
2. **Falls back to params if not in shared**: `or self.params.get("key")`
3. **Template resolver leverages this**: By putting resolved values in params, they become available to nodes

Example flow:
- Planner extracts: `{"issue_number": "1234"}` from "fix issue 1234"
- Workflow has: `{"params": {"issue": "$issue_number"}}`
- Template resolver: Puts "1234" in node's params
- Node's prep(): `shared.get("issue") or self.params.get("issue")` gets "1234"

This elegant pattern means nodes don't need modification to support templates!

## Implementation Design

### Core Components

1. **TemplateResolver**: Detects and resolves template variables with path support
2. **TemplateAwareNodeWrapper**: Wraps nodes to provide transparent resolution
3. **Compiler Integration**: Wraps nodes that have template parameters

### Resolution Process

1. Detect template variables in parameters
2. At runtime, build context from shared store + planner parameters
3. Resolve paths by traversing nested objects
4. Replace templates with string values
5. Update node params before execution

## Code Implementation

### Phase 1: Template Resolver

```python
# src/pflow/runtime/template_resolver.py

import re
from typing import Dict, Set, Any, Optional

class TemplateResolver:
    """Handles template variable detection and resolution with path support."""

    # Pattern supports both $var and ${var} formats with paths
    TEMPLATE_PATTERN = re.compile(r'\$\{?(\w+(?:\.\w+)*)\}?')

    @staticmethod
    def has_templates(value: Any) -> bool:
        """Check if value contains template variables."""
        return isinstance(value, str) and '$' in value

    @staticmethod
    def extract_variables(value: str) -> Set[str]:
        """Extract all template variable names (including paths)."""
        return set(TemplateResolver.TEMPLATE_PATTERN.findall(value))

    @staticmethod
    def resolve_value(var_name: str, context: Dict[str, Any]) -> Optional[Any]:
        """Resolve a variable name (possibly with path) from context."""
        if '.' in var_name:
            # Handle path traversal like github_main.issue_data.title
            parts = var_name.split('.')
            value = context
            for part in parts:
                if isinstance(value, dict) and part in value:
                    value = value[part]
                else:
                    return None
            return value
        else:
            # Simple variable
            return context.get(var_name)

    @staticmethod
    def resolve_string(template: str, context: Dict[str, Any]) -> str:
        """Resolve all template variables in a string."""
        result = template

        for match in TemplateResolver.TEMPLATE_PATTERN.finditer(template):
            var_name = match.group(1)
            value = TemplateResolver.resolve_value(var_name, context)

            if value is not None:
                # Convert to string - explicit handling for None
                if value is None:
                    value_str = ""
                else:
                    value_str = str(value)

                # Replace both $var and ${var} formats
                result = result.replace(f'${{{var_name}}}', value_str)
                result = result.replace(f'${var_name}', value_str)

        return result
```

### Phase 2: Node Wrapper

```python
# src/pflow/runtime/node_wrapper.py

from typing import Dict, Any, Optional
from .template_resolver import TemplateResolver

class TemplateAwareNodeWrapper:
    """Wraps nodes to provide transparent template resolution.

    This is the runtime proxy that enables "Plan Once, Run Forever".
    """

    def __init__(self, inner_node, node_id: str, initial_params: Optional[Dict[str, Any]] = None):
        """
        Args:
            inner_node: The actual node being wrapped
            node_id: Node identifier from IR (creates namespace in shared store)
            initial_params: Parameters extracted by planner from natural language
        """
        self.inner_node = inner_node
        self.node_id = node_id  # Node ID creates namespace: shared[node_id]
        self.initial_params = initial_params or {}  # From planner extraction
        self.template_params = {}
        self.static_params = {}

    def set_params(self, params: Dict[str, Any]):
        """Separate template params from static params."""
        self.template_params.clear()
        self.static_params.clear()

        for key, value in params.items():
            if TemplateResolver.has_templates(value):
                self.template_params[key] = value
            else:
                self.static_params[key] = value

        # Set only static params on inner node
        self.inner_node.set_params(self.static_params)

    def _run(self, shared: Dict[str, Any]) -> Any:
        """Execute with template resolution."""
        # Skip if no templates
        if not self.template_params:
            return self.inner_node._run(shared)

        # Build resolution context: shared store + planner parameters
        # Planner parameters have higher priority (come second in update)
        context = dict(shared)  # Start with shared store (includes node namespaces)
        context.update(self.initial_params)  # Planner parameters override

        # Resolve all template parameters
        resolved_params = {}
        for key, template in self.template_params.items():
            resolved_params[key] = TemplateResolver.resolve_string(template, context)

        # Temporarily update inner node params
        original_params = self.inner_node.params
        merged_params = {**self.static_params, **resolved_params}
        self.inner_node.params = merged_params

        try:
            # Execute with resolved params
            return self.inner_node._run(shared)
        finally:
            # Restore original (though node copy will be discarded)
            self.inner_node.params = original_params

    def __getattr__(self, name):
        """Delegate all other attributes to inner node."""
        return getattr(self.inner_node, name)
```

### Phase 3: Compiler Integration

```python
# Modifications to src/pflow/runtime/compiler.py

def compile_ir_to_flow(
    ir_dict: Dict[str, Any],
    registry: Registry,
    initial_params: Optional[Dict[str, Any]] = None
) -> Flow:
    """Compile IR with template variable support.

    Args:
        ir_dict: The workflow IR containing template variables
        registry: Node registry
        initial_params: Parameters extracted by planner from natural language
                       Example: {"issue_number": "1234", "repo": "pflow"}
                       from user saying "fix github issue 1234 in pflow repo"
    """
    flow = Flow()
    nodes = {}
    initial_params = initial_params or {}

    # Create nodes
    for node_spec in ir_dict['nodes']:
        node_id = node_spec['id']
        node_type = node_spec['type']
        params = node_spec.get('params', {})

        # Get node class and instantiate
        node_class = registry.get(node_type)
        node = node_class()

        # Check if any parameters contain templates
        has_templates = any(TemplateResolver.has_templates(v) for v in params.values())

        if has_templates:
            # Wrap node for template support (runtime proxy)
            node = TemplateAwareNodeWrapper(node, node_id, initial_params)

        # Set parameters (wrapper will separate template vs static)
        node.set_params(params)
        nodes[node_id] = node
        flow.add_node(node_id, node)

    # Add edges
    for edge in ir_dict.get('edges', []):
        flow.add_edge(edge['from'], edge.get('action', 'default'), edge['to'])

    # Set start node
    if 'start_node' in ir_dict:
        flow.set_start(ir_dict['start_node'])

    return flow
```

## Complete End-to-End Example

Let's trace the complete flow from natural language to execution:

```python
# 1. User Input
user_input = "fix github issue 1234 in pflow repo"

# 2. Planner Extracts Parameters
planner_output = {
    "workflow_ir": {
        "ir_version": "0.1.0",
        "nodes": [
            {
                "id": "get_issue",
                "type": "github-get-issue",
                "params": {
                    "issue": "$issue_number",
                    "repo": "$repo"
                }
            },
            {
                "id": "analyze",
                "type": "claude-code",
                "params": {
                    "prompt": "Fix issue #$get_issue.issue_data.number: $get_issue.issue_data.title\nRepo: $repo"
                }
            }
        ],
        "edges": [{"from": "get_issue", "to": "analyze"}]
    },
    "parameter_values": {
        "issue_number": "1234",
        "repo": "pflow"
    }
}

# 3. CLI Compiles with Template Support
flow = compile_ir_to_flow(
    planner_output["workflow_ir"],
    registry,
    initial_params=planner_output["parameter_values"]
)

# 4. Execution - First Node (get_issue)
# Template resolution for get_issue node:
# - $issue_number → "1234" (from initial_params)
# - $repo → "pflow" (from initial_params)
# Node receives: {"issue": "1234", "repo": "pflow"}

# Node executes and writes to shared store:
shared["get_issue"] = {
    "issue_data": {
        "number": 1234,
        "title": "Bug in login flow",
        "user": {"login": "john"}
    }
}

# 5. Execution - Second Node (analyze)
# Template resolution for analyze node:
# - $get_issue.issue_data.number → "1234" (from shared store)
# - $get_issue.issue_data.title → "Bug in login flow" (from shared store)
# - $repo → "pflow" (from initial_params)
# Node receives: {"prompt": "Fix issue #1234: Bug in login flow\nRepo: pflow"}
```

## Testing Strategy

### Core Tests

```python
# tests/test_runtime/test_template_resolver.py

def test_planner_parameter_flow():
    """Test parameters extracted by planner from natural language."""
    # Simulating planner extraction from "fix github issue 1234"
    planner_params = {
        "issue_number": "1234",
        "repo": "pflow"
    }

    template = "Working on issue $issue_number in $repo"
    result = TemplateResolver.resolve_string(template, planner_params)
    assert result == "Working on issue 1234 in pflow"

def test_node_namespace_pattern():
    """Test the node ID namespacing pattern."""
    # Nodes write to shared[node_id]
    context = {
        "github_main": {
            "issue_data": {
                "number": 1234,
                "title": "Main bug",
                "user": {"login": "alice"}
            }
        },
        "github_fork": {
            "issue_data": {
                "number": 5678,
                "title": "Fork bug",
                "user": {"login": "bob"}
            }
        }
    }

    template = "Main: $github_main.issue_data.title by $github_main.issue_data.user.login"
    result = TemplateResolver.resolve_string(template, context)
    assert result == "Main: Main bug by alice"

def test_priority_planner_over_shared():
    """Test that planner parameters override shared store values."""
    wrapper = TemplateAwareNodeWrapper(
        TestNode(),
        "test",
        initial_params={"issue_number": "1234"}  # From planner
    )
    wrapper.set_params({"message": "Issue $issue_number"})

    shared = {"issue_number": "5678"}  # Different value in shared
    result = wrapper._run(shared)
    assert "Issue 1234" in result  # Planner value wins

def test_real_workflow_template():
    """Test template from actual task 17 workflow."""
    context = {
        "get_issue": {
            "issue_data": {
                "number": 1234,
                "title": "Bug in login",
                "user": {"login": "john"},
                "body": "Login fails when..."
            }
        },
        "analyze": {
            "code_report": "Fixed by updating auth logic"
        }
    }

    # Template from task 17's example workflow
    template = "Fix #$get_issue.issue_data.number: $analyze.code_report"
    result = TemplateResolver.resolve_string(template, context)
    assert result == "Fix #1234: Fixed by updating auth logic"

def test_type_conversions():
    """Test explicit type conversion rules."""
    context = {
        "none_val": None,
        "empty_str": "",
        "zero": 0,
        "false": False,
        "empty_list": [],
        "empty_dict": {}
    }

    assert TemplateResolver.resolve_string("[$none_val]", context) == "[]"
    assert TemplateResolver.resolve_string("[$empty_str]", context) == "[]"
    assert TemplateResolver.resolve_string("[$zero]", context) == "[0]"
    assert TemplateResolver.resolve_string("[$false]", context) == "[False]"
    assert TemplateResolver.resolve_string("[$empty_list]", context) == "[[]]"
    assert TemplateResolver.resolve_string("[$empty_dict]", context) == "[{}]"
```

### Integration Tests

```python
def test_complete_workflow_with_planner_params():
    """Test full workflow execution with planner-extracted parameters."""
    # Workflow IR from planner
    ir = {
        "nodes": [
            {
                "id": "get_issue",
                "type": "github-get-issue",
                "params": {
                    "issue": "$issue_number",
                    "repo": "$repo"
                }
            },
            {
                "id": "display",
                "type": "echo",
                "params": {
                    "message": "Issue $get_issue.issue_data.title in $repo"
                }
            }
        ],
        "edges": [{"from": "get_issue", "to": "display"}]
    }

    # Parameters extracted from "fix issue 1234 in pflow"
    planner_params = {
        "issue_number": "1234",
        "repo": "pflow"
    }

    flow = compile_ir_to_flow(ir, registry, planner_params)
    shared = {}
    flow.run(shared)

    # Verify correct resolution throughout execution
    assert shared["get_issue"]["issue_data"]["number"] == 1234
    # Echo node should have received resolved message
```

## Common Pitfalls and Solutions

### 1. Type Loss Through String Conversion
**Problem**: `$count` with value 3 becomes "3" (string)
**Solution**: Document this MVP limitation. All template values become strings. The planner validates paths exist using structure documentation.

### 2. Non-existent Paths
**Problem**: `$data.field.missing` when path doesn't exist
**Solution**: Leave template unchanged for debugging visibility

### 3. Array Access
**Problem**: User wants `$items.0.name` for array access
**Solution**: Not supported in MVP. Document as future enhancement.

### 4. Missing Variables
**Problem**: Template references variable not in planner params or shared store
**Solution**: Leave template unchanged - this helps debugging and matches planner validation

### 5. Complex Objects
**Problem**: `$user` where user is a complex object
**Solution**: Converts to string representation using str()

## Success Criteria

The implementation is complete when:

1. **Path-based access works**:
   ```json
   {"prompt": "Fix issue #$get_issue.issue_data.number by $get_issue.issue_data.user.login"}
   ```

2. **Planner parameters work**:
   ```python
   # From "fix github issue 1234":
   planner_params = {"issue_number": "1234"}
   # Template $issue_number resolves correctly
   ```

3. **Dynamic values work**:
   - Templates can reference shared store values from previous nodes
   - Node namespacing through IDs works naturally
   - Nested paths traverse objects correctly

4. **Nodes remain unmodified**:
   - Existing nodes work without changes
   - Template resolution is transparent via runtime proxy

## MVP Limitations

Document these clearly for users:
1. All values convert to strings
2. No array indexing (`$items.0`)
3. No complex expressions or transformations
4. No fallback values or defaults
5. Missing paths leave template unchanged

## Implementation Checklist

- [ ] Implement TemplateResolver with path support
- [ ] Create comprehensive test suite for path traversal
- [ ] Implement TemplateAwareNodeWrapper
- [ ] Integrate with compiler
- [ ] Test with real pflow nodes
- [ ] Document template syntax for users
- [ ] Add examples with nested paths
- [ ] Test edge cases (missing paths, null values)

This implementation provides powerful template variable support with path traversal, enabling most workflow parameterization needs without the complexity of proxy mappings. It serves as the runtime proxy that makes pflow's "Plan Once, Run Forever" philosophy possible.
