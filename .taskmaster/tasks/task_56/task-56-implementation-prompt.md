# Task 56: Runtime Validation & Error Feedback Loop - Agent Instructions

## The Problem You're Solving
Workflows generated by the planner guess external data shapes (HTTP JSON, MCP outputs) and tool arguments. This leads to runtime failures (missing fields, bad args). Users currently must fix these manually. We need an automated runtime feedback loop that executes the candidate workflow, captures fixable runtime errors, and routes them back to the generator for correction up to 3 attempts.

## Your Mission
Implement a planner-stage runtime validation loop with a new RuntimeValidationNode that executes the candidate workflow, classifies runtime issues, and triggers a targeted ‚Äúruntime-fix‚Äù regeneration. Extend the HTTP node with deterministic extraction and structured errors. Support MCP tools by harvesting namespaced errors and missing downstream paths.

## Required Reading (IN THIS ORDER)

### 1. FIRST: Understand the Epistemic Approach
**File**: `.taskmaster/workflow/epistemic-manifesto.md`

### 2. SECOND: Brain dump context
**File**: `.claude/commands/braindump.md`

### 3. THIRD: Task Overview
**File**: `.taskmaster/tasks/task_56/task-56.md`

### 4. Read ALL Context Files
**Directory**: `.taskmaster/tasks/task_56/starting-context/`

**Files to read (in this order):**
1. `task-56-spec.md` - The specification (source of truth for requirements and tests)
2. `task-56-implementation-plan.md` - Step-by-step implementation plan

**Instructions**: Read these files and follow the spec precisely. The spec defines the rules, wiring, error model, and test criteria that MUST be satisfied.

## What You're Building
A planner runtime feedback loop:
- New node `RuntimeValidationNode` added to planner nodes.
- Flow wiring: `metadata_generation >> runtime_validation`; `runtime_validation - "runtime_fix" >> workflow_generator`; `runtime_validation - "failed_runtime" >> result_preparation`; `runtime_validation >> parameter_preparation`.
- HTTP node extraction with structured `RuntimeValidationError` on missing paths.
- MCP support via namespaced error detection and downstream template path checks.

Example IR downstream template target after fix:
```json
{
  "params": {
    "prompt": "User: ${http_user.extracted.username} - Bio: ${http_user.extracted.biography}"
  }
}
```

## Key Outcomes You Must Achieve

### Planner Runtime Loop
- Add `RuntimeValidationNode` with actions: default, `runtime_fix`, `failed_runtime`.
- Execute candidate workflow once; collect issues; decide route.
- Maintain `runtime_attempts` and cap at 3.

### HTTP Node Extraction
- Support `params.extract: { alias: "$.path" }` with simple dot/array paths.
- On success: include `extracted` in exec result and in namespaced shared.
- On failure: raise `RuntimeValidationError` with attempted, available keys, sample, message.

### MCP Handling
- Detect namespaced `error` in MCP node outputs.
- Detect missing downstream `${mcp_node.*}` paths post-exec.
- Classify fixable vs fatal per spec and route appropriately.

## Implementation Strategy

### Phase 1: Node and Error Foundations (2‚Äì3h)
1. Add `RuntimeValidationError` to `src/pflow/core/exceptions.py` with required fields.
2. Extend HTTP node in `src/pflow/nodes/http/http.py`:
   - Parse `extract` param, implement dot/array path resolver.
   - Success ‚Üí add `extracted` to result; Failure ‚Üí raise `RuntimeValidationError`.
   - Ensure exec_fallback re-raises `RuntimeValidationError` unchanged.

### Phase 2: Planner Integration (2‚Äì3h)
1. Implement `RuntimeValidationNode` in `src/pflow/planning/nodes.py`:
   - `prep`: read `generated_workflow`, `execution_params`, `runtime_attempts`.
   - `exec`: compile+run candidate with fresh shared store; return `{ok, shared_after, result}` or `{ok: False, error, exception}`.
   - `post`: build `shared["runtime_errors"]` by: exceptions, namespaced errors, IR-vs-shared missing template paths; route.
2. Wire node in `src/pflow/planning/flow.py` as specified.
3. Update `WorkflowGeneratorNode` to consume `runtime_errors` (switch to runtime-fix prompt), without changing outputs.

### Phase 3: Tests (2‚Äì3h)
1. HTTP unit tests: extraction success; failure raises structured error.
2. RuntimeValidationNode unit tests: default/no-issues; namespaced error; exception; missing template paths; attempts increment and cap.
3. MCP path test: simulate namespaced error or missing downstream path ‚Üí `runtime_fix`.
4. Integration: planner E2E loop for HTTP guess‚Üífix‚Üísuccess.

## Use Subagents effectively
- @agent-pflow-codebase-searcher: locate exact integration points, confirm wiring patterns and planner node conventions.
- @agent-test-writer-fixer: author/fix tests per spec after implementation.
- Deploy subagents in parallel for read-only discovery and test writing. Keep implementation changes single-agent to avoid conflicts.

## Critical Technical Details

### Template Path Discovery
- Use or replicate `TemplateValidator._extract_all_templates` to find `${node_id.path}` references in IR params.
- Only treat `${node_id.*}` as downstream output references (exclude plain inputs).

### Namespaced Shared Access
- After execution, each node namespace is under `shared_after[node_id]`.
- Check `"error" in shared_after[node_id]` to collect node-level errors (e.g., MCP).

## Critical Warnings from Experience

### Don‚Äôt swallow RuntimeValidationError
- HTTP `exec_fallback` must re-raise `RuntimeValidationError`. Converting it to ValueError will lose structure.

### Don‚Äôt re-run static validations
- RuntimeValidationNode must not re-check schema or template validity covered by `ValidatorNode`.

## Key Decisions Already Made
1. Execute all nodes during runtime validation (no dry-run gating) for MVP.
2. Use simple dot/array paths (not full JSONPath) for HTTP extract.
3. Classify fixable issues (extraction/arg/path) vs fatal (auth/network/non-JSON/attempts exhausted).
4. Cap runtime attempts at 3; any additional issues route `failed_runtime`.

## Success Criteria
- ‚úÖ All spec Test Criteria pass
- ‚úÖ `make test` passes without regressions
- ‚úÖ `make check` passes (lint, type, format)
- ‚úÖ Planner flow shows new wiring and actions
- ‚úÖ HTTP extraction behavior matches spec (keys, error formatting)
- ‚úÖ MCP issues detected and classified per spec

## Common Pitfalls to Avoid
- DON‚ÄôT add a `raw` return key to HTTP; keep `response` + `extracted` only.
- DON‚ÄôT alter ValidatorNode behavior or planner compile order.
- DON‚ÄôT mutate original execution_params or shared; use a fresh shared store in RuntimeValidationNode.exec().

## üìã Create Your Implementation Plan FIRST
Before coding, confirm the plan in `task-56-implementation-plan.md` matches the codebase reality. If conflicts are found, update the plan and note deltas in your progress log.

## Your Implementation Order
1. Create progress log at `.taskmaster/tasks/task_56/implementation/progress-log.md` and start logging.
2. Implement `RuntimeValidationError`.
3. Extend HTTP node (extract + errors).
4. Implement `RuntimeValidationNode` (prep/exec/post).
5. Wire flow in `flow.py` and update generator to read `runtime_errors`.
6. Write tests (HTTP, node, integration). Run `make test`.
7. Run `make check` and fix issues.
8. Update docs if needed.

## Real-Time Learning Capture
Append insights, failures, and code snippets to the progress log as you work.

## Handle Discoveries and Deviations
If code realities differ from plan/spec, STOP, record the issue, and propose the minimal deterministic adjustment in your progress log before proceeding.

## Test Creation Guidelines
Use @agent-test-writer-fixer for authoring high-signal tests focused on public APIs, runtime loop behavior, and error edge cases.

## What NOT to Do
- DON‚ÄôT add new CLI flags or planner config
- DON‚ÄôT introduce third-party JSONPath libraries
- DON‚ÄôT change existing node error contracts beyond HTTP additions

## Getting Started
- Run planner tests to confirm baseline
- Implement `RuntimeValidationError` and HTTP extract
- Add `RuntimeValidationNode` scaffold and wire flow
- Execute targeted tests for each step

## Final Notes
Follow the spec in `task-56-spec.md` precisely; it is the source of truth for required rules, actions, and tests.

## Remember
This loop makes pflow learn external structures at generation time, then run deterministically afterwards. Your implementation unlocks ‚ÄúPlan Once, Run Forever‚Äù for real-world APIs and tools.
