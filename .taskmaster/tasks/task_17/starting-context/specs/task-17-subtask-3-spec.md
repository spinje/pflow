# Feature: task_17_subtask_3_parameter_management

## Objective

Implement parameter discovery, extraction, and preparation nodes for workflow execution.

## Requirements

- Must implement ParameterDiscoveryNode for analyzing user input parameter needs
- Must implement ParameterMappingNode as the convergence point for both paths
- Must implement ParameterPreparationNode for formatting execution parameters
- Must support template variable syntax ($var and $data.field notation)
- Must extract parameters independently without trusting upstream analysis
- Must validate all required workflow parameters are found
- Must handle both user_input and stdin_data as parameter sources
- Must add all three nodes to existing nodes.py module (created in subtask 2)

## Scope

- Does not implement array indexing syntax ($data[0])
- Does not implement complex proxy mappings or transformations
- Does not modify workflow IR or node definitions
- Does not handle workflow execution

## Inputs

- user_input: str - Natural language request from user
- stdin_data: Optional[Any] - Data piped from stdin
- found_workflow: Optional[dict] - Workflow IR from Path A discovery
- generated_workflow: Optional[dict] - Workflow IR from Path B generation
- workflow_metadata: dict - Extracted metadata about the workflow
  # Path A: Loaded from saved workflow via WorkflowManager
  # Path B: Generated by MetadataGenerationNode after validation

## Outputs

Returns: Updated shared store with parameter extraction results

Side effects:
- discovered_params: dict - Parameter hints for generation (ParameterDiscoveryNode)
- extracted_params: dict - Actual parameter values found (ParameterMappingNode)
- execution_params: dict - Final parameters ready for workflow execution
- verified_params: dict - Validation details and status

## Structured Formats

```python
# ParameterDiscoveryNode output format
discovered_params = {
    "state": "closed",
    "limit": "20"
    # Simple dict mapping parameter names to values
    # Used by GeneratorNode for template variable context
    # ParameterMappingNode does NOT use this (does fresh extraction)
}

# ParameterMappingNode output format
extracted_params = {
    "filename": "report.csv",
    "data": {"field": "value"}  # For template path access
}

execution_params = {
    "filename": "report.csv",
    "data": {"field": "value"}
}

verified_params = {
    "status": "success",  # or "missing_required"
    "missing": [],  # List of missing required params
    "warnings": []  # Optional warnings
}

# Workflow IR inputs structure (from workflow_metadata)
workflow_ir = {
    "inputs": {
        "filename": {
            "description": "Input file to process",
            "required": true,  # defaults to true if not specified
            "type": "string"
        },
        "output_format": {
            "description": "Output format",
            "required": false,
            "type": "string",
            "default": "json"
        }
    }
}
```

## State/Flow Changes

- Path A: discovery → found_workflow → parameter_mapping → parameter_prep → result
- Path B: discovery → browsing → param_discovery → generation → validation → metadata → parameter_mapping → parameter_prep → result
- Both paths converge at ParameterMappingNode, then proceed through ParameterPreparationNode

## Constraints

- Template variables limited to $var and $data.field syntax
- Parameter names must match workflow's declared inputs exactly
- ParameterMapping must work independently of discovered_params

## Rules

1. ParameterDiscoveryNode analyzes user_input for parameter hints
2. ParameterDiscoveryNode outputs empty parameters list if none found
3. ParameterMappingNode extracts parameters from scratch
4. ParameterMappingNode validates against workflow's inputs field
5. ParameterMappingNode fails if input with required=true is missing
6. Template paths resolve using dot notation only
7. Stdin_data checked as fallback parameter source
8. Parameter names preserve exact case from workflow inputs
9. Execution_params contains final validated parameters
10. ParameterPreparationNode formats extracted_params into execution_params
11. ParameterPreparationNode runs after successful parameter mapping

## Edge Cases

Empty user_input → ParameterDiscovery returns empty discovered_params
No workflow provided → ParameterMapping raises ValueError
Required param missing → ParameterMapping sets status "missing_required"
Malformed template path → Skip parameter, log warning
Stdin_data is None → Check only user_input for parameters
Template path not in data → Parameter excluded from execution_params

## Error Handling

- None

## Non-Functional Criteria

- Parameter extraction completes in < 100ms
- LLM calls use structured output with retries
- Clear error messages identify missing parameters

## Examples

```python
# ParameterDiscoveryNode example
user_input = "process the sales report.csv file and convert to json"
discovered_params = {
    "filename": "report.csv",
    "output_format": "json"
}

# ParameterMappingNode example
workflow_ir = {
    "inputs": {
        "filename": {
            "description": "File to process",
            "required": True,
            "type": "string"
        },
        "output_format": {
            "description": "Output format",
            "required": True,
            "type": "string"
        },
        "delimiter": {
            "description": "CSV delimiter",
            "required": False,
            "type": "string",
            "default": ","
        }
    }
}
user_input = "convert report.csv to json"

extracted_params = {
    "filename": "report.csv",
    "output_format": "json"
}

verified_params = {
    "status": "success",
    "missing": [],
    "warnings": []
}

# ParameterPreparationNode example
# In MVP, this is a pass-through that prepares for future transformations
extracted_params = {"filename": "report.csv", "output_format": "json"}
execution_params = extracted_params.copy()  # Direct pass-through in MVP
```

## Test Criteria

1. ParameterDiscoveryNode with valid input produces discovered_params dict
2. ParameterDiscoveryNode with empty input returns empty parameters list
3. ParameterDiscoveryNode detects stdin_data type when present
4. ParameterMappingNode extracts all required parameters successfully
5. ParameterMappingNode fails when input with required=true is missing
6. ParameterMappingNode ignores discovered_params in extraction
7. Template path $data.field resolves correctly
8. Template path $var resolves to direct value
9. Stdin_data used when user_input lacks parameter
10. Case sensitivity preserved from workflow inputs field
11. All three nodes added to existing nodes.py file
12. Invalid template syntax logged but not fatal
13. Path A workflow takes priority over Path B
14. Missing inputs with required=false do not cause failure
15. Execution_params ready for workflow execution
16. ParameterPreparationNode preserves all parameters in MVP
17. All three nodes execute in correct sequence

## Notes (Why)

- Independent extraction ensures security and validation
- Convergence architecture enables both reuse and generation paths
- Template paths cover 90% of use cases without complex mappings
- Clear separation between discovery hints and actual extraction

## Compliance Matrix

| Rule # | Covered By Test Criteria # |
| ------ | -------------------------- |
| 1      | 1, 3                       |
| 2      | 2                          |
| 3      | 4, 6                       |
| 4      | 4, 5                       |
| 5      | 5                          |
| 6      | 7, 8                       |
| 7      | 9                          |
| 8      | 10                         |
| 9      | 15                         |
| 10     | 16                         |
| 11     | 17                         |

## Versioning & Evolution

- v1.0.0 — Initial parameter management specification for Task 17 Subtask 3

## Epistemic Appendix

### Assumptions & Unknowns

- Verified: LLM library fully supports Pydantic models for structured output
- Verified: Workflow IR uses `inputs` field with `required`, `type`, `description` subfields
- Verified: Template syntax is $var and $data.field with dot notation
- Verified: nodes.py created in subtask 2 will contain all three parameter nodes
- Unknown: Full set of parameter patterns in user language

### Conflicts & Resolutions

- Documentation suggests reusing discovered_params — Resolution: Independent extraction per security principles
- Array indexing mentioned in some docs — Resolution: Not supported in MVP per core documentation
- Initial assumption of required_params/optional_params fields — Resolution: Workflow IR uses `inputs` field with `required` boolean per input

### Decision Log / Tradeoffs

- Chose independent extraction over parameter reuse for security and validation
- Chose simple dot notation over complex path expressions for MVP simplicity
- Chose to make ParameterMapping the single convergence point for clarity
- Chose empty dict over None for no parameters found (consistency)

### Ripple Effects / Impact Map

- All downstream execution depends on ParameterPreparationNode output
- Workflow execution readiness gates on ParameterMapping success
- Future proxy mapping features will extend these nodes
- Testing requires mock workflows with parameter declarations

### Residual Risks & Confidence

- Risk: Parameter patterns not recognized by discovery; Mitigation: Best-effort hints
- Risk: Template paths more complex than anticipated; Mitigation: Clear error messages
- Risk: Missing required parameters block execution; Mitigation: Detailed error reporting
- Confidence: High - architecture validated through documentation review

### Epistemic Audit (Checklist Answers)

1. Assumed LLM structured output and workflow metadata format
2. Wrong format assumptions would break parameter validation
3. Prioritized robustness (independent extraction) over efficiency
4. All rules map to test criteria
5. Impacts workflow execution and all downstream nodes
6. Parameter pattern recognition uncertain; Confidence: High overall
