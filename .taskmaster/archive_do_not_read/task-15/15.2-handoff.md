# Subtask 15.2 Handoff: Two-Phase Context Functions

**IMPORTANT**: Do not begin implementing yet. Read this entire handoff first and confirm you're ready to begin.

## üéØ Critical Context You Need to Know

### You're Building on Top of 15.1
Subtask 15.1 is now DONE. This means:
- `_load_saved_workflows()` function exists and works (lines 328-383)
- Helper functions `_validate_workflow_fields()` and `_load_single_workflow()` exist
- Test workflows exist in `~/.pflow/workflows/`
- The workflow loading infrastructure is ready for you to use

### The Core Problem You're Solving
The Natural Language Planner (Task 17) gets overwhelmed when given ALL node details at once. Your two-phase approach solves this:
1. **Discovery Phase**: Show all available components with just names/descriptions (browsing)
2. **Planning Phase**: Show full details ONLY for selected components (implementation)

This is like the difference between browsing a library catalog vs reading specific books.

### Core Outcomes This Subtask Must Deliver

1. **`build_discovery_context(node_ids=None, workflow_names=None)`**:
   - Lightweight markdown with names/descriptions only
   - Groups nodes by category (use existing `_group_nodes_by_category()`)
   - Includes workflows alongside nodes
   - Omits missing descriptions (no placeholders)
   - `None` means "include all available"
   - Gets registry from singleton: `from pflow.registry import get_registry`

2. **`build_planning_context(selected_node_ids, selected_workflow_names, registry_metadata, saved_workflows=None)`**:
   - Full interface details for selected components ONLY
   - Returns error dict if components missing: `{"error": "...", "missing_nodes": [...], "missing_workflows": [...]}`
   - Uses existing `_format_node_section()` for node details
   - Applies exclusive params pattern (params in Reads filtered out)
   - Leverages existing `_process_nodes()` for metadata extraction

### üö® Critical Implementation Details

#### The Registry Pattern You Must Use
```python
from pflow.registry import get_registry

def build_discovery_context(node_ids=None, workflow_names=None):
    """Build lightweight discovery context."""
    registry = get_registry()
    registry_metadata = registry.get_metadata()

    # If node_ids is None, use all nodes
    if node_ids is None:
        node_ids = list(registry_metadata.keys())
```

#### Existing Functions to Reuse
- **Line 20**: MAX_OUTPUT_SIZE = 200KB (not 50KB!)
- **Lines 58-199**: `_process_nodes()` - Extracts metadata with dynamic imports
- **Lines 229-253**: `_group_nodes_by_category()` - Groups by module path
- **Lines 385-521**: `_format_node_section()` - Formats full node details
- **Lines 328-383**: `_load_saved_workflows()` - Your subtask 15.1 work!

#### Parser Warnings (DO NOT TOUCH)
From metadata_extractor.py (not your file):
- **Line 374**: Comma-aware regex for shared keys
- **Line 444**: Comma-aware regex for params
- **Line 416**: Exclusive params pattern
- These patterns are EXTREMELY fragile - one change broke 20+ tests

### Key Decisions Already Made

From `.taskmaster/tasks/task_15/task-15-context-builder-ambiguities.md`:

1. **Discovery Context Format** (Decision 5):
   ```markdown
   ## Available Nodes

   ### File Operations
   ### read-file
   Read content from a file and add line numbers for display

   ### write-file
   Write content to a file with automatic directory creation

   ### AI/LLM Operations
   ### llm
   General-purpose language model for text processing

   ## Available Workflows

   ### test-data-pipeline (workflow)
   Processes user data through multiple transformations
   ```

2. **Missing Components Handling** (Decision 8 - CRITICAL):
   - Return error dict, NOT partial context
   - Enable discovery retry with error info
   - Never silently skip missing components
   - This prevents broken workflows

3. **Backward Compatibility** (User clarification):
   - `build_context()` does NOT need backward compatibility
   - Can be refactored to use your functions
   - Only tests use it, no production code

### Expected Output Examples

#### Discovery Context (Lightweight)
```markdown
## Available Nodes

### File Operations
### read-file
Read content from a file and add line numbers for display

### copy-file
Copy a file from source to destination with safety checks

### Test Operations
### test-node
Basic test node for unit testing

## Available Workflows

### test-data-pipeline (workflow)
Processes user data through multiple transformations

### backup-files (workflow)
Creates timestamped backups of specified files
```

Note: If a node has no description, just show the name (no placeholder text).

#### Planning Context (Detailed) or Error
Success case:
```markdown
## Selected Components

### read-file
Read content from a file and add line numbers for display

**Inputs**:
- `file_path: str` - Path to the file to read
- `encoding: str` - File encoding (default: utf-8)

**Outputs**:
- `content: str` - File contents with line numbers
- `error: str` - Error message if operation failed

**Parameters**:
- `validate: bool` - Validate file exists before reading
```

Error case (THIS IS A DICT, NOT MARKDOWN):
```python
{
    "error": "Missing components detected:\n- Unknown nodes: github-get-isue\n  (Check spelling, use hyphens not underscores)\n",
    "missing_nodes": ["github-get-isue"],
    "missing_workflows": []
}
```

### Essential Context Documents (READ THESE FIRST)

**‚ö†Ô∏è CRITICAL**: Read these Task 15 documents for full context, but remember you're ONLY implementing subtask 15.2:
- `.taskmaster/tasks/task_15/task-15-context-builder-ambiguities.md` - All design decisions
- `.taskmaster/tasks/task_15/task-15-technical-implementation-guide.md` - Line numbers and patterns

These documents cover the ENTIRE Task 15, but you must ONLY implement:
- `build_discovery_context()` function
- `build_planning_context()` function
- Error handling for missing components

**DO NOT** implement:
- Workflow loading (already done in 15.1)
- Structure display enhancements (that's subtask 15.3)
- Combined JSON + paths format (that's subtask 15.3)
- Refactoring of `build_context()` (that's subtask 15.4)

### üß™ CRITICAL: Test-As-You-Go Strategy

**Tests are part of implementation, not a separate task!**

1. **Create tests alongside your code**:
   - Create `tests/test_planning/test_context_builder_phases.py`
   - Test discovery with 0, 10, 100 nodes
   - Test planning with selected components
   - Test error dict when components missing
   - Test workflow inclusion in both contexts
   - Use `tmp_path` fixture for test workflows

2. **Discovery Context Test Pattern**:
   ```python
   def test_discovery_context_lightweight(mock_registry):
       """Test discovery returns only names and descriptions."""
       # Mock registry with test data
       mock_registry.get_metadata.return_value = {
           "read-file": {
               "module_path": "pflow.nodes.file.read_file",
               "class_name": "ReadFileNode",
               "metadata": {
                   "description": "Read content from a file",
                   "inputs": [...],  # Full details
                   "outputs": [...]
               }
           }
       }

       context = build_discovery_context()

       # Should NOT contain interface details
       assert "**Inputs**" not in context
       assert "**Outputs**" not in context
       assert "**Parameters**" not in context

       # Should contain names and descriptions
       assert "### read-file" in context
       assert "Read content from a file" in context
   ```

3. **Missing Components Test Pattern**:
   ```python
   def test_planning_context_missing_nodes():
       """Test error dict when nodes missing."""
       result = build_planning_context(
           selected_node_ids=["read-file", "github-get-isue"],  # Typo!
           selected_workflow_names=[],
           registry_metadata={"read-file": {...}},
           saved_workflows=[]
       )

       assert isinstance(result, dict)
       assert "error" in result
       assert "missing_nodes" in result
       assert "github-get-isue" in result["missing_nodes"]
   ```

4. **Run tests continuously**:
   - After each function: `pytest tests/test_planning/test_context_builder_phases.py -v`
   - Before finalizing: `make test`
   - Check quality: `make check`

### Anti-Patterns to Avoid

1. **Don't modify parser regex** - They're working but fragile
2. **Don't implement structure formatting** - That's 15.3
3. **Don't skip missing components** - Return error dict
4. **Don't add placeholders** for missing descriptions
5. **Don't reimplement existing functions** - Reuse what works
6. **Don't create new helper functions** unless absolutely necessary

### What Would Make Me Furious If I Forgot to Mention

1. **Parameter defaults**: `node_ids=None` means "all nodes", not "no nodes"
2. **Workflow marking**: Add " (workflow)" suffix in discovery to distinguish from nodes
3. **Error dict is INSTEAD of markdown**, not alongside it - if error, return dict only
4. **Exclusive params pattern** is already in `_format_node_section()` - don't duplicate
5. **Categories matter**: Use existing category grouping for better organization
6. **The planner expects EXACTLY this format** - don't get creative
7. **Load workflows ONCE**: Call `_load_saved_workflows()` in discovery, pass to planning
8. **Check workflows by name**: `any(w['name'] == workflow_name for w in saved_workflows)`

### Integration Points

Your functions will be called by:
- The Natural Language Planner (Task 17) for two-phase discovery
- `build_context()` after refactoring in subtask 15.4
- Tests that verify the two-phase approach works

The planner flow:
1. Call `build_discovery_context()` ‚Üí Show user all options
2. LLM selects relevant components
3. Call `build_planning_context(selected)` ‚Üí Get details
4. If error dict returned ‚Üí Go back to step 1 with corrections

### Tricky Edge Cases

1. **Empty registry**: Should return "No nodes available" section
2. **No workflows**: Should still have "## Available Workflows" section (empty)
3. **All components missing**: Error dict with both lists populated
4. **Node exists but no metadata**: Use `_process_nodes()` to extract it
5. **Workflow with same name as node**: They're in different sections, no conflict

### Performance Considerations

From the ambiguities document:
- **No artificial limits** - Modern LLMs have huge contexts
- **200KB is plenty** - Don't worry about size
- **Load all workflows at once** - Simpler than lazy loading
- The challenge is **disambiguation**, not size

---

**Remember**: Read all of this first, understand the context, then confirm you're ready to begin implementation. The two-phase context functions you create are the core deliverable that enables the planner to avoid LLM overwhelm.
