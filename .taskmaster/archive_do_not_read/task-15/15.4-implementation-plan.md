# Task 15.4 Implementation Plan: Integration and Comprehensive Testing

## üéØ Mission Statement

Your goal is to create comprehensive testing and documentation for the two-phase context builder system that was implemented in Task 15. The functionality is complete and working, but lacks proper integration tests and documentation of the enhanced docstring format.

## üìã Success Criteria

- [ ] Enhanced docstring format is fully documented with examples
- [ ] Integration tests cover the full discovery ‚Üí planning workflow
- [ ] Edge cases are tested (performance, Unicode, concurrency)
- [ ] Test coverage > 90% for context builder module
- [ ] All tests pass (`make test` succeeds)
- [ ] Code quality checks pass (`make check` succeeds)
- [ ] Documentation is clear and includes working examples

## üöÄ Phase-by-Phase Implementation

### Phase 1: Document Enhanced Docstring Format (Estimated: 2 hours)

#### 1.1 Create Documentation File

**File**: `architecture/reference/enhanced-interface-format.md`

**Content Structure**:
```markdown
# Enhanced Interface Format for pflow Nodes

## Overview
The enhanced interface format enables automatic extraction of structured metadata...

## Basic Syntax
```python
"""
Node description here.

Interface:
- Reads: shared["input_key"]: type  # Description
- Writes: shared["output_key"]: type  # Description
- Params: param_name: type  # Description (default: value)
"""
```

## Structure Documentation
For complex data types (dict, list), you can document their structure:

```python
"""
Interface:
- Writes: shared["user_data"]: dict  # User information
    - id: str  # User ID
    - profile: dict  # User profile data
      - name: str  # Full name
      - email: str  # Email address
    - tags: list  # User tags
      - name: str  # Tag name
"""
```

## Parser Rules and Limitations
1. Use double quotes only: `shared["key"]` ‚úÖ, `shared['key']` ‚ùå
2. Empty sections break parser - always include content
3. Indentation matters for structures (2 spaces per level)
4. Commas in descriptions can break parsing - use alternative phrasing
5. Supported types: str, int, float, bool, dict, list

## Examples from Real Nodes
[Include examples from test_node_structured.py and file nodes]
```

#### 1.2 Add Cross-References

Update these files to reference the new documentation:
- `src/pflow/nodes/CLAUDE.md` - Add link to enhanced format docs
- `architecture/index.md` - Add entry in reference section
- `.taskmaster/tasks/task_15/README.md` - Update with documentation link

#### 1.3 Create Interactive Examples

**File**: `examples/enhanced-docstring-examples.py`

Include working examples of:
- Simple interface documentation
- Nested structure documentation
- Array/list documentation
- Edge cases and limitations

### Phase 2: Integration Tests (Estimated: 3-4 hours)

#### 2.1 Create Test File

**File**: `tests/test_integration/test_context_builder_integration.py`

**Test Structure**:
```python
"""Integration tests for two-phase context builder system."""

import pytest
from unittest.mock import patch
from pflow.registry import Registry
from pflow.planning.context_builder import (
    build_discovery_context,
    build_planning_context,
    _load_saved_workflows
)


class TestDiscoveryPlanningFlow:
    """Test the complete discovery ‚Üí planning workflow."""

    def test_full_discovery_to_planning_flow(self):
        """Test complete two-phase workflow with real registry."""

    def test_discovery_planning_with_workflows(self):
        """Test workflow integration in both phases."""

    def test_error_recovery_flow(self):
        """Test error handling and recovery in planning phase."""


class TestStructureIntegration:
    """Test structure display in planning context."""

    def test_planning_with_structured_nodes(self):
        """Test planning context includes structure display."""

    def test_structure_format_correctness(self):
        """Verify structure format matches Decision 9 requirements."""


class TestRealWorldScenarios:
    """Test with realistic node combinations."""

    def test_file_operation_workflow(self):
        """Test discovery and planning for file operations."""

    def test_mixed_node_types(self):
        """Test with different node categories."""
```

#### 2.2 Key Test Cases to Implement

1. **Full Discovery ‚Üí Planning Flow**:
   ```python
   def test_full_discovery_to_planning_flow(self):
       # Load real registry
       registry = Registry()
       metadata = registry.load()

       # Discovery phase - should include all nodes
       discovery = build_discovery_context(registry_metadata=metadata)
       assert "## Available Nodes" in discovery
       assert "### File Operations" in discovery
       assert "read-file" in discovery

       # Simulate LLM selection
       selected_nodes = ["read-file", "write-file"]

       # Planning phase - should show detailed interfaces
       planning = build_planning_context(selected_nodes, [], metadata)
       assert "## Selected Components" in planning
       assert "**Inputs**:" in planning
       assert "**Outputs**:" in planning
   ```

2. **Structure Display Integration**:
   ```python
   def test_planning_with_structured_nodes(self):
       # Use test_node_structured which has nested structures
       from pflow.nodes.test_node_structured import TestNodeStructured

       # Create mock registry with structured node
       registry_metadata = {
           "test-structured": {
               "module": "pflow.nodes.test_node_structured",
               "class_name": "TestNodeStructured"
           }
       }

       planning = build_planning_context(["test-structured"], [], registry_metadata)

       # Verify combined format appears
       assert "Structure (JSON format):" in planning
       assert "Available paths:" in planning
       assert "user_data.profile.name" in planning  # Path example
   ```

3. **Error Recovery Flow**:
   ```python
   def test_error_recovery_flow(self):
       registry_metadata = {"real-node": {"module": "test", "class_name": "Test"}}

       # Try planning with non-existent node
       result = build_planning_context(
           ["real-node", "fake-node"], [], registry_metadata
       )

       # Should return error dict
       assert isinstance(result, dict)
       assert "error" in result
       assert "missing_nodes" in result
       assert "fake-node" in result["missing_nodes"]

       # Error message should help user
       assert "Check spelling" in result["error"]
   ```

#### 2.3 Workflow Integration Tests

Create test workflows and verify they appear in discovery and planning:

```python
def test_workflow_integration(self):
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create test workflow
        workflow_file = Path(tmpdir) / "test-workflow.json"
        workflow_data = {
            "name": "test-workflow",
            "description": "Test workflow for integration",
            "inputs": ["file_path"],
            "outputs": ["processed_data"],
            "ir": {"nodes": [], "flows": []},
            "created_at": "2024-01-01T00:00:00Z"
        }
        workflow_file.write_text(json.dumps(workflow_data))

        # Mock workflow directory
        with patch("pflow.planning.context_builder._load_saved_workflows") as mock:
            mock.return_value = [workflow_data]

            # Discovery should include workflow
            discovery = build_discovery_context()
            assert "test-workflow (workflow)" in discovery

            # Planning should show workflow details
            planning = build_planning_context([], ["test-workflow"], {})
            assert "## Selected Workflows" in planning
```

### Phase 3: Edge Case Tests (Estimated: 2 hours)

#### 3.1 Performance Tests

**File**: `tests/test_integration/test_context_builder_performance.py`

```python
def test_large_registry_performance(self):
    """Test performance with many nodes."""
    import time

    # Create registry with 1000 mock nodes
    large_registry = {}
    for i in range(1000):
        large_registry[f"node-{i}"] = {
            "module": "test.module",
            "class_name": "TestNode",
            "description": f"Test node {i}"
        }

    # Discovery should complete quickly
    start_time = time.time()
    discovery = build_discovery_context(registry_metadata=large_registry)
    discovery_time = time.time() - start_time

    assert discovery_time < 1.0  # Should complete in < 1 second
    assert "node-999" in discovery  # Should include all nodes

    # Planning with subset should also be fast
    start_time = time.time()
    planning = build_planning_context(
        [f"node-{i}" for i in range(10)], [], large_registry
    )
    planning_time = time.time() - start_time

    assert planning_time < 0.5  # Should be even faster
```

#### 3.2 Unicode and Special Characters

```python
def test_unicode_in_descriptions(self):
    """Test handling of Unicode characters."""
    registry_metadata = {
        "unicode-node": {
            "module": "test.module",
            "class_name": "TestNode",
            "description": "Node with √©mojis üöÄ and ‰∏≠Êñá characters"
        }
    }

    discovery = build_discovery_context(registry_metadata=registry_metadata)
    planning = build_planning_context(["unicode-node"], [], registry_metadata)

    # Should handle Unicode gracefully
    assert "√©mojis üöÄ" in discovery
    assert "‰∏≠Êñá" in planning
```

#### 3.3 Concurrent Access Tests

```python
def test_concurrent_workflow_loading(self):
    """Test thread safety of workflow loading."""
    import threading
    import tempfile
    from pathlib import Path

    # Create multiple workflow files
    with tempfile.TemporaryDirectory() as tmpdir:
        for i in range(10):
            workflow_file = Path(tmpdir) / f"workflow-{i}.json"
            workflow_data = {
                "name": f"workflow-{i}",
                "description": f"Workflow {i}",
                "inputs": [], "outputs": [], "ir": {}
            }
            workflow_file.write_text(json.dumps(workflow_data))

        # Load workflows concurrently
        results = []
        def load_workflows():
            with patch("pflow.planning.context_builder.Path.home") as mock_home:
                mock_home.return_value = Path(tmpdir).parent
                workflows = _load_saved_workflows()
                results.append(len(workflows))

        threads = [threading.Thread(target=load_workflows) for _ in range(5)]
        for t in threads:
            t.start()
        for t in threads:
            t.join()

        # All threads should get same result
        assert all(count == results[0] for count in results)
```

### Phase 4: Coverage and Documentation (Estimated: 1 hour)

#### 4.1 Coverage Analysis

```bash
# Run coverage for context builder module
uv run pytest tests/test_planning/ tests/test_integration/ \
    --cov=src/pflow/planning/context_builder \
    --cov-report=html \
    --cov-report=term-missing

# Open coverage report
open htmlcov/index.html
```

**Coverage Targets**:
- `build_discovery_context()`: > 95%
- `build_planning_context()`: > 95%
- `_format_structure_combined()`: > 90%
- All helper functions: > 90%
- Error paths: > 80%

#### 4.2 Missing Coverage Analysis

Identify uncovered lines and add targeted tests:

```python
def test_uncovered_edge_cases(self):
    """Test specific edge cases found in coverage analysis."""

    # Test empty workflow list
    result = build_discovery_context(workflow_names=[])
    assert "## Available Workflows" not in result

    # Test invalid registry structure
    with pytest.raises(TypeError):
        build_planning_context(["node"], [], "not-a-dict")

    # Test workflow loading with permission errors
    with patch("pathlib.Path.iterdir") as mock_iter:
        mock_iter.side_effect = PermissionError("Access denied")
        workflows = _load_saved_workflows()
        assert workflows == []  # Should handle gracefully
```

#### 4.3 Documentation Validation

Create tests that validate documentation examples:

```python
def test_documentation_examples(self):
    """Verify examples in documentation actually work."""

    # Test the examples from enhanced-interface-format.md
    from pflow.nodes.test_node_structured import TestNodeStructured

    # Verify the documented structure format appears
    registry = {"test-structured": {
        "module": "pflow.nodes.test_node_structured",
        "class_name": "TestNodeStructured"
    }}

    planning = build_planning_context(["test-structured"], [], registry)

    # Should match documented format exactly
    assert "Structure (JSON format):" in planning
    assert "Available paths:" in planning
```

## üéØ Implementation Sequence

### Day 1: Documentation (2 hours)
1. Create `architecture/reference/enhanced-interface-format.md`
2. Add examples and limitations
3. Update cross-references
4. Create example file

### Day 2: Core Integration Tests (3 hours)
1. Create integration test file
2. Implement discovery ‚Üí planning flow tests
3. Add structure integration tests
4. Test error recovery scenarios

### Day 3: Edge Cases and Polish (2 hours)
1. Add performance tests
2. Test Unicode handling
3. Add concurrency tests
4. Run coverage analysis

### Day 4: Final Validation (1 hour)
1. Ensure all tests pass
2. Verify coverage targets
3. Update documentation
4. Final quality checks

## üß™ Test Data and Fixtures

### Useful Test Fixtures

```python
@pytest.fixture
def mock_registry():
    """Registry with various node types for testing."""
    return {
        "read-file": {
            "module": "pflow.nodes.file.read_file",
            "class_name": "ReadFileNode"
        },
        "test-structured": {
            "module": "pflow.nodes.test_node_structured",
            "class_name": "TestNodeStructured"
        }
    }

@pytest.fixture
def temp_workflow_dir():
    """Temporary directory with test workflows."""
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create sample workflows
        yield Path(tmpdir)
```

### Test Node for Structure Testing

Use `TestNodeStructured` from `src/pflow/nodes/test_node_structured.py` - it has:
- Nested dict structures
- List/array structures
- Multiple output types
- Perfect for testing the combined format

## ‚ö†Ô∏è Common Pitfalls to Avoid

1. **Don't test file nodes for structures** - They don't have any
2. **Use mocking for Registry.load()** - Don't depend on actual installed nodes
3. **Test both success and error paths** - Error handling is critical
4. **Include timing assertions** - Performance matters for large registries
5. **Mock workflow directory** - Don't write to actual ~/.pflow/workflows/

## üèÅ Definition of Done

- [ ] All new tests pass
- [ ] Coverage > 90% for context builder module
- [ ] Documentation is complete with working examples
- [ ] `make test` passes (all 500+ tests)
- [ ] `make check` passes (linting, type checking)
- [ ] Integration tests demonstrate full workflow value
- [ ] Edge cases are covered (performance, Unicode, concurrency)
- [ ] No regressions in existing functionality

The implementation is complete when a developer (or AI agent) can read the documentation, understand the enhanced format, write nodes using it, and use the two-phase context system effectively for building workflows.
